#+TITLE: Let's Go: Golang inside and outside outlined
#+AUTHOR: Zhou Peng
#+EMAIL: p@ctriple.cn

* Let's Go: Golang inside and outside outlined                            :TOC_4_gh:noexport:
- [[#part-1-outside][Part 1: Outside]]
  - [[#introduction][Introduction]]
  - [[#language-elements][Language Elements]]
  - [[#array-and-slice][Array and Slice]]
  - [[#map][Map]]
  - [[#make-vs-new][Make vs New]]
  - [[#function][Function]]
  - [[#struct-and-method][Struct and Method]]
  - [[#interface][Interface]]
  - [[#reflect][Reflect]]
  - [[#channel-and-concurrency][Channel and Concurrency]]
  - [[#tool-chains][Tool Chains]]
- [[#part-2-inside][Part 2: Inside]]
  - [[#memory-alloc--free][Memory Alloc & Free]]
  - [[#garbage-collection][Garbage Collection]]
  - [[#goroutine-schedule][Goroutine Schedule]]
  - [[#slice-internals][Slice internals]]
  - [[#string-internals][String internals]]
  - [[#channel-internals][Channel internals]]
  - [[#map-internals][Map internals]]

* Part 1: Outside

** Introduction

#+BEGIN_SRC go
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
#+END_SRC

Following conclusions can be made:
- Source code is full UTF-8 encoded
- Golang is static typed, that means you need to compile then run
- Unlike many other static language, go code does not need semicolon to terminate a statement
- Package is the smallest public module
- Public/Private is controlled by Uppercase or Lowercase, like =Println= is public

Let's build and run the example:

#+BEGIN_SRC bash
go run hello.go
Hello, 世界
#+END_SRC

** Language Elements

- Golang has only 25 keywords

|          |             |        |           |        |
|----------+-------------+--------+-----------+--------|
| break    | default     | func   | interface | select |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

- And 36 builtin functions or types

|        |         |         |         |        |         |           |            |         |
|--------+---------+---------+---------+--------+---------+-----------+------------+---------|
| append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |
| copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |
| int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |
| print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |

- Difference between keywords and builtins

In one word, =builtins= are just predefined functions or types by the go
compiler, which can be redefined by users for other purpose, but =keywords= can
only be used as the =language spec= explained.

- Keywords grouped by their mainly used cases

|        |                 |                       |                 |               |
|--------+-----------------+-----------------------+-----------------+---------------|
| Golang | Basic Structure | Variable and Constant | =var=           |               |
|        |                 |                       | =const=         |               |
|        |                 | Pakcage Management    | =package=       |               |
|        |                 |                       | =import=        |               |
|        |                 |                       |                 |               |
|        | Basic Elements  | Function              | =func=          |               |
|        |                 |                       | =return=        |               |
|        |                 | User-Defined Type     | =interface=     |               |
|        |                 |                       | =struct=        |               |
|        |                 | Reference Type        | =map=           |               |
|        |                 |                       | =range=         |               |
|        |                 |                       |                 |               |
|        | Control Flow    | Concurrency           | =go=            |               |
|        |                 |                       | =select=        |               |
|        |                 |                       | =chan=          |               |
|        |                 | Single-Task Control   | Single Branch   | =if=          |
|        |                 |                       |                 | =else=        |
|        |                 |                       | Multiple Branch | =switch=      |
|        |                 |                       |                 | =case=        |
|        |                 |                       |                 | =default=     |
|        |                 |                       |                 | =fallthrough= |
|        |                 |                       | Loop            | =for=         |
|        |                 |                       |                 | =break=       |
|        |                 |                       |                 | =continue=    |
|        |                 |                       | Jump            | =goto=        |
|        |                 |                       |                 |               |
|        | Defered Flow    | =defer=               |                 |               |

** Array and Slice

#+BEGIN_SRC text
Struct Memory Layout
====================

struct type
-----------

       type Point struct { x, y int }


Initialized with new
--------------------

         new(Point)
       +-------------+
       |     *       | *Point
       +------\------+
               \
                +-----+-----+
                |  0  |  0  | Point
                +-----+-----+


Initialized as a struct literal
-------------------------------

       p := Point{10, 20}
         +-----+-----+
         |  0  |  0  | Point
         +-----+-----+

       pp := &Point{10, 20}
         +--------+
         |    *   | *Point
         +-----\--+
                \
                 +-----+-----+
                 |  0  |  0  | Point
                 +-----+-----+


Memory layout of a struct of structs
====================================

    type Rect1 struct { Min, Max Point }
    type Rect2 struct { Min, Max *Point }

        r1 := Rect1{Point{10, 20}, Point{50,60}}
            +----+----+----+----+
            | 10 | 20 | 50 | 60 | Rect1
            +----+----+----+----+

        r2 := Rect2{&Point{10, 20}, &Point{50, 60}}
            +--------+--------+
            |   *    |    *   | Rect2
            +----\---+-------\+
                  \           \
                   +----+----+ +----+----+
                   | 10 | 20 | | 50 | 60 | Point
                   +----+----+ +----+----+
#+END_SRC

Golang =array= details:
- Array's memory is allocated as a whole, which makes array access much more efficient
- Array's length is part of array type, which means =[5]int= does equal to =[2]int=

Golang =slice= details:
- Slice is just a descriptor of an array, consists of 3 parts: =ptr= to
  underlying memory block, =len= length of current slice, =cap= the underline
  memory block capabilities.
- So copy slice is just copy 3 small integers, but copy array is copy the whole
  memory block, which makes slice much more useful in many situations.

** Map

#+BEGIN_SRC go
package main

func main() {
	bytes := make(map[string]int)
	bytes["KB"] = 1 << 10
	bytes["MB"] = 1 << 20
	bytes["GB"] = 1 << 30
	bytes["TB"] = 1 << 40
	bytes["PB"] = 1 << 50
	bytes["ZB"] = 1 << 60

	for unit, byte := range bytes {
		println(unit, byte)
	}
}
#+END_SRC

Map's notes:
- Map is reference type, you need make() to create one
- Traversal sequence is not guaranteed the same as they were put

** Make vs New

#+BEGIN_SRC go
package main

func main() {
  a := new([5]int)
  s := make([]int, 5)
  a[0] = 1
  s[0] = 1
  println(a[0])
  println(s[0])
}
#+END_SRC

Golang has three builtin reference types, aka Slice/Map/Chan. You can treat
reference just like a pointer or descriptor, if you new these three reference
types, you only allocate memory for the pointer or descriptor (think about
linux's file descriptor); but many other are not allocated, like slice's
underlying array, map's hash buckets, chan's buffer for messages. So, golang have
to use a special syntax to completely initialize these reference types.

** Function

#+BEGIN_SRC go
package main

func main() {
  s := new(int)
  *s = 1024
  println(*s)
}
#+END_SRC

#+BEGIN_SRC shell
go build -gcflags="-l -m" t.go
# command-line-arguments
./t.go:4 main new(int) does not escape
#+END_SRC

Golang belongs to C language family, function is the basic block to describe the
process of algorithms, and encapsulate to reuse code. Golang's function
distinguished from C in multiple return values, named return value, and not
strictly difference between stack and heap variables; Golang compiler will take
escape analysis when code get compiled, so programmer new a variable does not
mean to it will be placed on the heap finally.

** Struct and Method

#+BEGIN_SRC go
package main

type Gopher struct {
	OS     string
	Editor string
	Lang   string
}

func (g *Gopher) WhoAmI() {
	println("    Operating System:", g.OS)
	println("       Coding Editor:", g.Editor)
	println("Programming Language:", g.Lang)
}

func main() {
	g := Gopher{
		OS:     "Linux",
		Editor: "Emacs",
		Lang:   "Golang",
	}
	g.WhoAmI()
}
#+END_SRC

Golang has struct type to composite small units to represent large and
complicated objects. method is just function with the first argument being
specified with the specific type's object. The two concepts together is equal to
OOP like Java/C++, but more rely on composition than inheritance. Which one is
better can not be made easy, but Golang's approach is more simple and less
trouble obviously.

** Interface

#+BEGIN_SRC go
package main

type Gopher interface {
	OS() string
	Editor() string
	Lang() string
}

type ChinaGopher struct {
	os     string
	editor string
	lang   string
}

func (cgo *ChinaGopher) OS() string {
	return cgo.os
}

func (cgo *ChinaGopher) Editor() string {
	return cgo.editor
}

func (cgo *ChinaGopher) Lang() string {
	return cgo.lang
}

func main() {
	cgo := &ChinaGopher{
		os:     "Linux",
		editor: "Vim",
		lang:   "Go",
	}
	var g Gopher = cgo
	println(g.OS())
	println(g.Editor())
	println(g.Lang())
}
#+END_SRC

Golang interface is collection of methods, we say one type has implemented one
interface when this type's methods set is a super set of interface's method set.
Besides, interface is implemented automatically, that means type does not need
to declare in advance, and no special language syntax need to quantify this
relationship between type and interface (such as Java's 'extends' keyword). If
you assign a type variable which does not have all the methods required by the
interface to the interface variable, go compiler will complain, and emit an
compile time error. In conclusion, Golang's interface is used like an dynamic
language like Python and also be in safety like an static language like Java.

** Reflect

#+BEGIN_SRC go
package main

import "fmt"

func main() {
	udf := struct {
		i int
		f float32
		s string
	}{
		i: 10,
		f: 10.0,
		s: "Hello, World!",
	}
	fmt.Println(10)              // int
	fmt.Println(10.0)            // float
	fmt.Println("Hello, World!") // string
	fmt.Println(udf)             // user defined
}
#+END_SRC

Golang standard library "fmt" has a magic function 'Println()', which can print
out any variables of any types. We know that Golang neither support function
override like Java/C++, nor does it support default arguments. So how could this
happen? Golang's answer is empty =interface{}=, which is equal to Object in many
other OOP languages. As to =Println()=, it has only one variadic argument
=...interface{}=. Like C, Golang object doesn't keep track of typeinfo, runtime
cannt require any typeinfo from object itself. Reflection is based on interface
var, which store both object's data and type.

- func TypeOf(i interface{}) Type
- func ValueOf(i interface{}) Value

** Channel and Concurrency

#+BEGIN_SRC go
package main

import (
	"fmt"
	"net/http"
	"os"
)

// Simple count server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	*ctr++
	fmt.Fprintf(w, "counter = %d\n", *ctr)
}

// A channel what sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	ch <- req
	fmt.Fprint(w, "notification sent")
}

// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintln(w, os.Args)
}

func main() {
	ctr := new(Counter)
	http.Handle("/counter", ctr)

	ch := make(Chan, 5)
	go func(ch Chan) {
		for {
			req := <-ch
			fmt.Println(req.Host, req.Method, req.UserAgent())
		}
	}(ch)
	http.Handle("/notify", ch)

	http.Handle("/args", http.HandlerFunc(ArgServer))
	http.ListenAndServe(":8080", nil)
}
#+END_SRC

Code above implement a full stack HTTP server, no application container, no HTTP
server like Nginx, it's Go way. =Goroutine= represents runnable object, and
=Channel= is how these standalone runnable objects communicate with each other.
Both are simple to create and easy to use, but also very powerful. By the way,
function in golang is the first-class object, that means a function variable is
just like a basic variable like int, which can be created at run time, passed by
value, and even make methods of a function.

** Tool Chains

- gofmt

The end of coding style wars

- go test

Functionality, code coverage and performance test built into the language

- godef & gocode & guru

Auto-complement, function jumping, definition reference etc

- go get

Fetch project dependencies from the internet

Golang is a language that built with tools in mind. Tools are easy to be
created, and many other wonderful tools is already ready. Golang has helped soft
engineering capabilities much, that's a good news to big company with hundreds
of developers who working together.

* Part 2: Inside

** Memory Alloc & Free

** Garbage Collection

** Goroutine Schedule

** Slice internals

** String internals

** Channel internals

** Map internals
