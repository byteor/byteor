LLVM Language Reference Manual
==============================

#Abstract
#Introductoin
  -Well-Formedness
#Identifiers
#High Level Structure
  -Module Structure
  -Linkage Types
  -Calling Conventions
  -Visibility Styles
  -DLL Storage Classes
  -Thread Local Storage Models
  -Structure Types
  -Global Variables
  -Functions
  -Aliases
  -Comdats
  -Named Metadata
  -Parameter Attributes
  -Garbage Collector Strategy Names
  -Prefix Data
  -Prologue Data
  -Personality Function
  -Attribute Groups
  -Function Attributes
  -Operand Bundles
    +Deoptimization Operand Bundles
  -Module-Level Inline Assembly
  -Data Layout
  -Target Triple
  -Pointer Aliasing Rules
  -Volatile Memory Accesses
  -Memory Model for Concurrent Operations
  -Atomic Memory Ordering Constraints
  -Fast-Math Flags
  -Use-list Order Directives
#Type System
  -Void Type
  -Function Type
  -First Class Types
    +Single Value Types
      *Integer Type
      *Floating Point Types
      *X86_mmx Type
      *Pointer Type
      *Vector Type
    +Label Type
    +Token Type
    +Metadata Type
    +Aggregate Types
      *Array Type
      *Structure Type
      *Opaque Structure Types
#Constants
  -Simple Constants
  -Complex Constants
  -Global Variable and Function Addresses
  -Undefined Values
  -Posion Values
  -Addresses of Basic Blocks
  -Constant Expressions
#Other Values
  -Inline Assembler Expressions
    +Inline Asm Constraint String
      *Output constraints
      *Input constraints
      *Indirect inputs and outputs
      *Clobber constraints
      *Constraint Codes
      *Supported Constraint Code List
    +Asm template argument modifiers
    +Inline Asm Metadata
#Metadata
  -Metadata Nodes and Metadata Strings
    +Specialized Metadata Nodes
      *DLCompileUnit
      *DLFile
      *DLBasicType
      *DLSubroutineType
      *DLDerivedType
      *DLCompositeType
      *DLSubrange
      *DLEnumerator
      *DLTemplateTypeParameter
      *DLTemplateValueParameter
      *DLNamespace
      *DLGlobalVariable
      *DLSubprogram
      *DLLexicalBlock
      *DLLexicalBlockFile
      *DLLocation
      *DLLocalVariable
      *DLExpression
      *DLObjCProperty
      *DLImportedEntity
    +`tbaa` Metadata
    +`tbaa.struct` Metadata
    +`noalias` and `alias.scope` Metadata
    +`fpmath` Metadata
    +`range` Metadata
    +`unpredictable` Metadata
    +`llvm.loop`
    +`llvm.loop.vectorize` and `llvm.loop.interleave`
    +`llvm.loop.interleave.count` Metadata
    +`llvm.loop.vectorize.enable` Metadata
    +`llvm.loop.vectorize.width` Metadata
    +`llvm.loop.unroll`
    +`llvm.loop.unroll.count` Metadata
    +`llvm.loop.unroll.disable` Metadata
    +`llvm.loop.unroll.runtime.disable` Metadata
    +`llvm.loop.unroll.enable` Metadata
    +`llvm.loop.unroll.full` Metadata
    +`llvm.mem`
    +`llvm.mem.parallel_loop_access` Metadata
    +`llvm.bitsets`
    +`invariant.group` Metadata
#Module Flags Metadata
  -Objective-C Garbage Collection Module Flags Metadata
  -Automatic Linker Flags Module Flags Metadata
  -C type width Module Flags Metadata
#Intrinsic Global Variables
  -The `llvm.used` Global Variable
  -The `llvm.compiler.used` Global Variable
  -The `llvm.global_ctors` Global Variable
  -The `llvm.global_dtors` Global Variable
#Instruction Reference
  -Terminator Instructions
    +`ret` Instruction
    +`br` Instruction
    +`switch` Instruction
    +`indirectbr` Instruction
    +`invoke` Instruction
    +`resume` Instruction
    +`catchpad` Instruction
    +`catchendpad` Instruction
    +`catchret` Instruction
    +`cleanupendpad` Instruction
    +`cleanupret` Instruction
    +`terminatepad` Instruction
    +`unreachable` Instruction
  -Binary Operations
    +`add` Instruction
    +`fadd` Instruction
    +`sub` Instruction
    +`fsub` Instruction
    +`mul` Instruction
    +`fmul` Instruction
    +`udiv` Instruction
    +`sdiv` Instruction
    +`fdiv` Instruction
    +`urem` Instruction
    +`srem` Instruction
    +`frem` Instruction
  -Bitwise Binary Operations
    +`shl` Instruction
    +`lshr` Instruction
    +`ashr` Instruction
    +`and` Instruction
    +`or` Instruction
    +`xor` Instruction
  -Vector Operations
    +`extractelement` Instruction
    +`insertelement` Instruction
    +`shufflevector` Instruction
  -Aggregate Operations
    +`extractvalue` Instruction
    +`insertvalue` Instruction
  -Memory Access and Addressing Operations
    +`alloca` Instruction
    +`load` Instruction
    +`store` Instruction
    +`fence` Instruction
    +`cmpxchg` Instruction
    +`atomicrmw` Instruction
    +`getelementptr` Instruction
  -Conversion Operations
    +`trunc .. to` Instruction
    +`zext .. to` Instruction
    +`sext .. to` Instruction
    +`fptrunc .. to` Instruction
    +`fpext .. to` Instruction
    +`fptoui .. to` Instruction
    +`fptosi .. to` Instruction
    +`uitofp .. to` Instruction
    +`sitofp .. to` Instruction
    +`ptrtoint .. to` Instruction
    +`inttoptr .. to` Instruction
    +`bitcast .. to` Instruction
    +`addrspacecast .. to` Instruction
  -Other Operations
    +`icmp` Instruction
    +`fcmp` Instruction
    +`phi` Instruction
    +`select` Instruction
    +`call` Instruction
    +`va_arg` Instruction
    +`landingpad` Instruction
    +`cleanuppad` Instruction
#Intrinsic Functions
  -Variable Argument Handling Intrinsics
    +`llvm.va_start` Intrinsic
    +`llvm.va_end` Intrinsic
    +`llvm.va_copy` Intrinsic
  -Accurate Garbage Collectoin Intrinsics
    +Experimental Statepoint Intrinsics
    +`llvm.gcroot` Intrinsic
    +`llvm.gcread` Intrinsic
    +`llvm.gcwrite` Intrinsic
  -Code Generator Intrinsic
    +`llvm.returnaddress` Intrinsic
    +`llvm.frameaddress` Intrinsic
    +`llvm.localscape` and `llvm.localrecover` Intrinsics
    +`llvm.read_register` and `llvm.write_register` Intrinsics
    +`llvm.stacksave` Intrinsic
    +`llvm.stackrestore` Intrinsic
    +`llvm.prefetch` Intrinsic
    +`llvm.pcmarker` Intrinsic
    +`llvm.readcyclecounter` Intrinsic
    +`llvm.clear_cache` Intrinsic
    +`llvm.instrprof_increment` Intrinsic
    +`llvm.instrprof_value_profile` Intrinsic
  -Standard C Library Intrinsic
    +`llvm.memcpy` Intrinsic
    +`llvm.memmove` Intrinsic
    +`llvm.memset.*` Intrinsic
    +`llvm.sqrt.*` Intrinsic
    +`llvm.powi.*` Intrinsic
    +`llvm.sin.*` Intrinsic
    +`llvm.cos.*` Intrinsic
    +`llvm.pow.*` Intrinsic
    +`llvm.exp.*` Intrinsic
    +`llvm.exp2.*` Intrinsic
    +`llvm.log.*` Intrinsic
    *`llvm.log10.*` Intrinsic
    +`llvm.log2.*` Intrinsic
    +`llvm.fma.*` Intrinsic
    +`llvm.fabs.*` Intrinsic
    +`llvm.minnum.*` Intrinsic
    +`llvm.maxnum.*` Intrinsic
    +`llvm.copysign.*` Intrinsic
    +`llvm.floor.*` Intrinsic
    +`llvm.ceil.*` Intrinsic
    +`llvm.trunc.*` Intrinsic
    +`llvm.rint.*` Intrinsic
    +`llvm.nearbyint.*` Intrinsic
    +`llvm.round.*` Intrinsic
  -Bit Manipulation Intrinsic
    +`llvm.bitreverse.*` Intrinsic
    +`llvm.bswap.*` Intrinsic
    +`llvm.ctpop.*` Intrinsic
    +`llvm.ctlz.*` Intrinsic
    +`llvm.cttz.*` Intrinsic
  -Arithmetic with Overflow Intrinsic
    +`llvm.sadd.with.overflow.*` Intrinsic
    +`llvm.uadd.with.overflow.*` Intrinsic
    +`llvm.ssub.with.overflow.*` Intrinsic
    +`llvm.usub.with.overflow.*` Intrinsic
    +`llvm.smul.with.overflow.*` Intrinsic
    +`llvm.umul.with.overflow.*` Intrinsic
  -Specialised Arithmetic Intrinsic
    +`llvm.canoicalize.*` Intrinsic
    +`llvm.fmuladd.*` Intrinsic
    +`llvm.uabsdiff.*` and `llvm.sabsdiff.*` Intrinsic
  -Half Precision Floating Point Intrinsic
    +`llvm.convert.to.fp16` Intrinsic
    +`llvm.convert.from.fp16` Intrinsic
  -Debugger Intrinsics
  -Exception Handling Intrinsics
  -Trampoline Intrinsics
    +`llvm.init.trampoline` Intrinsic
    +`llvm.adjust.trampoline` Intrinsic
  -Masked Vector Load and Store Intrinsics
    +`llvm.masked.load.*` Intrinsics
    +`llvm.masked.store.*` Intrinsics
  -Masked Vector Gather and Scatter Intrinsics
    +`llvm.masked.gather.*` Intrinsics
    +`llvm.masked.scatter.*` Intrinsics
  -Memory Use Markers
    +`llvm.lifetime.start` Intrinsic
    +`llvm.lifetime.end` Intrinsic
    +`llvm.invariant.start` Intrinsic
    +`llvm.invariant.end` Intrinsic
    +`llvm.invariant.group.barrier` Intrinsic
  -General Intrinsics
    +`llvm.var.annotation` Intrinsic
    +`llvm.ptr.annotation` Intrinsic
    +`llvm.annotation.*` Intrinsic
    +`llvm.trap` Intrinsic
    +`llvm.debugtrap` Intrinsic
    +`llvm.stackprotector` Intrinsic
    +`llvm.stackprotectorcheck` Intrinsic
    +`llvm.objectsize` Intrinsic
    +`llvm.expect` Intrinsic
    +`llvm.assume` Intrinsic
    +`llvm.bitset.test` Intrinsic
    +`llvm.donothing` Intrinsic
  -Stack Map Intrinsics


#Abstract

This document is a reference manual for the LLVM assembly language. LLVM is a
Static Signle Assignment (SSA) based representation that provides type safely,
low-level operations, flexibility, and the capability of representing `allr`
high-level language cleanly. It is the common code representation used throughout
all phases of the LLVM compilation strategy.


#Introduction

The LLVM code representation is designed to be used in three different forms:
as an in-memory compiler IR, as an on-disk bitcode representation (suitable for
fast loading by a Just-In-Time compiler), and as a human readable assembly
language representation. This allows LLVM to provide a powerful intermediate
representation for efficient compiler transformations and analysis, while
providing a natural means to debug and visualize the transformations. The three
different forms of LLVM are all equivalent. This document describes the human
readable representation and notation.

The LLVM representation aims to be light-weight and low-level while being expressive,
typed, and extensible at the same time. It aims to be a "universal IR" of sorts,
by being at a low enough level that high-level ideas may be cleanly mapped to it(
similar to how microprocessors are "universal IR's", allowing many source languages
to be mapped to them). By providing type information, LLVM can be used as the
target of optimizations: for example, through pointer analysis, it can be proven
that a C automatic variable is never accessed outside of the current function,
allowing it to be promoted to a simple SSA value instead of a memory location.


#Well-Formedness

It is important to note that this document describes `well formed` LLVM assembly
language. There is a different between what the parser accepts and what is
considered `well formed`. For example, the following instruction is syntatically
okay, but not well formed:

  %x = add i32 1, %x

because the definition of %x does not dominate all of its uses. The LLVM infrastructure
provides a verification pass that may be used to verify that an LLVM module is
well formed. This pass is automatically run by the parser after parsing input
assembly and by the optimizer before it outputs bitcode. The violations pointed
out by the verifier pass indicate bugs in transformation passes or input to the
passer.


#Identifiers

LLVM identifiers come in two basic types: global and local. Global identifier (
functions, global variables) begin with the '@' character. Local identifier (register
names, types) begin with the '%' character. Additionally, there are three different
formats for identifiers, for different purposes:

  1. Named values are represented as a string of characters with their prefix.
     For example, %foo, @DivisionByZero, %a.really.long.identifier. The actual
     regular expression used is `[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*`. Identifiers
     that require other characters in their names can be surrounded with quotes.
     Special characters may be escaped using "\xx" where xx is the ASCII code for
     the chareacter in hexadecimal. In this way, any character can be used in a
     name value, even quotes themselves. The '\01' prefix can be used on global
     variables to suppress mangling.
  2. Unnamed values are represented as an unsigned numeric value with their prefix.
     For example, %12, @2, %44.
  3. Constants, which are described in the section #Constants# below.

LLVM requires that values start with a prefix for two reasons: Compilers don't need
to worry about clashes with reserved words, and the set of reserved words may be
expanded in the future without penalty. Additionally, unnamed identifiers allow a
compiler to quickly come up with a temporary variable without having to avoid
symbol table conflicts.

Reserved words in LLVM are very similar to reserved words in other languages. There
are keywords for different opcodes (`add`, `bitcast`, `ret`, etc...), for primitive
type names (`void`, `i32`, etc...), and others. These reserved words cannot conflict
with variable names, because none of them start with a prefix character (`%` or `@`).

Here is an example of LLVM code to multiply the integer variable '%x' by 8:

The easy way:

  %result = mul i32 %X, 8

After strength reduction:

  %result = shl i32 %X, 3

And the hard way:

  %0 = add i32 %X, %X        ; yields i32:%0
  %1 = add i32 %0, %0        ; yields i32:%1
  %result = add i32 %1, %1

The last way of multiplying %X by 8 illustrates serveral important lexical features
of LLVM:

  1. Comments are delimited with a ';' and go until the end of the line.
  2. Unnamed temporaries are created when the result of a computation is not
     assigned to a named value.
  3. Unnamed temporaries are numbered sequentially (using a per-function incrementing
     counter, starting with 0). Note that basic blocks and unnamed function
     parameters are included in this numbering. For example, if the entry basic
     block is not given a label name and all function parameters are named, then
     it will get number 0.

It also shows a convention that we follow in this document. When demonstrating
instructions, we will follow an instruction with a comment that defines the type
and name of value produced.


#High Level Structure

-Module Structure

LLVM programs are composed of Module's, each of which is a translation unit of the
input programs. Each module consists of functions, global variables, and symbol
table entries. Modules may be combined together with the LLVM linker, which merges
function (and global variable) definitions, resolves forward declarations, and
merges symbol entries. Here is an example of the "hello world" module:

  ; Declare the string constant as a global constant.
  @.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"

  ; External declaration of the puts function.
  declare i32 @puts(i8* nocapture) nounwind

  ; Definition of main function
  define i32 @main() {  ; i32()*
    ; Convert [13 x i8]* to i8 *...
    %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0

    ; Call puts function to write out the string to stdout.
    call i32 @puts(i8* %cast210)
    ret i32 0
  }

  ; Named metadata
  !0 = !{i32 42, null, !"string"}
  !foo = !{!0}

This example is made up of a global variable named ".str", an external declaration
of the "puts" function, a function definition for "main" and named metadata "foo".

In general, a module is made up of a list of global values (where both functions
and global variables are global values). Global values are represented by a pointer
to a memory location (in this case, a pointer to an array of char, and a pointer
to a function), and have one of the following linkage types.


-Linkage Types
