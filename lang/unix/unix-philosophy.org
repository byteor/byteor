* Basic of the Unix Philosophy

** Rule of Modularity

Write simple parts connected by clean interfaces

** Rule of Clarity

Clarity is better than cleverness

** Rule of Composition

Design programs to be connected with other programs

** Rule of Separation

Separate policy from mechanism; separate interfaces from engines

** Rule of Simplicity

Design for simplicity; add complexity only where you must

** Rule of Parsimony

Write a big program only when it is clear by demonstration that nothing else
will do

** Rule of Transparency

Design for visibility to make inspection and debuging easier

** Rule of Robustness

Robustness is the child of transparency and simplicity
Software is transparent when you can look at it and immediately see what
is going on. It is simple when what is going on is uncomplicated enough
for a human brain to reason about all the potential cases without strain.

** Rule of Representation

Fold knowledge into data, so program logic can be stupid and robust

** Rule of Least Surprise

In interface design, always do the least surprising thing

** Rule of Silence

When a program has nothing surprising to say, it should say nothing

** Rule of Repair

Repair what you can -- but when you must fail, fail noisily and as soon as
possible

** Rule of Economy

Programmer time is expensive; conserve it in preference to machine time

** Rule of Generation

Avoid hand hacking; write programs to write programs when you can

** Rule of Optimization

Prototype before polishing. Get it working before you optimize it

** Rule of Diversity

Distrust all claims for one true way

** Rule of Extensibility

Design for the future, because it will be here sooner than you think

* KISS

** Keep It Simple, Stupid!

* Applying the Unix Philosophy

** Everything that can be a source- and destination-independent filter should be one
** Data streams should if at all possible be textual (so they can be viewed and filtered with standard tools)
** Database layouts and application protocols should if at all possible be textual (human-readable and human-editable)
** Complex front ends (user interfaces) should be cleanly separated from complex back ends
** Whenever possible, prototype in an interpreted language before coding C
** Mixing languages is better than writing everthing in one, if and only if using only that one is likely to overcomplicate the program
** Be generous in what you accept, rigorous in what you emit
** When filtering, never throw away information you don't need to
** Small is beautiful. Write programs that do as little as is consistent with getting the job done
