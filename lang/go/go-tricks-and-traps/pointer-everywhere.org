** Code

#+BEGIN_SRC go
package main

import "fmt"

type Location struct {
	loc float64
	log float64
}

func (l *Location) String() string {
	return fmt.Sprintf("<%f, %f>", l.loc, l.log)
}

func (l *Location) Reverse() {
	l.loc, l.log = l.log, l.loc
}

func main() {
	l := Location{loc: 101.7, log: 98.2}

	fmt.Println(l)

	l.Reverse()
	fmt.Println(l)
}
#+END_SRC

** Compile

#+BEGIN_SRC shell
go build -gcflags "-l -m" loc.go
# command-line-arguments
./loc.go:11: l.loc escapes to heap
./loc.go:11: l.log escapes to heap
./loc.go:10: (*Location).String l does not escape
./loc.go:11: (*Location).String ... argument does not escape
./loc.go:14: (*Location).Reverse l does not escape
./loc.go:21: l escapes to heap
./loc.go:24: l escapes to heap
./loc.go:21: main ... argument does not escape
./loc.go:23: main l does not escape
./loc.go:24: main ... argument does not escape
#+END_SRC

** Notes

The compiler has detected that *l* should be allocated on heap, so the GC take
the responsibility to manage lifecycle of *l*, that means more CPU cycles
consumed by GC, yet means lower performance.

Pointer vs Object
| Scenario      | Use Pointer | Use Object |
|---------------+-------------+------------|
| Small Object  | no          | yes        |
| Modify Object | yes         | no         |
