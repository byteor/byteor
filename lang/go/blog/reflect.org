#+TITLE: Laws of reflect
#+AUTHOR: Rob Pike
#+LINK: https://golang.org/blog/laws-of-reflection

* Reflection goes from interface value to reflection object

At the basic level, reflection is just a mechanism to examine the type and value
pair stored inside an interface variable. To get started, there are two types we
need to know about in =package reflect=: =Type= and =Value=. Those two types
give access to the contents of an interface variable, and two simple functions,
called =reflect.TypeOf= and =reflect.ValueOf=, retrieve =reflect.Type= and
=reflect.Value= pieces out of an interface value. (Also, from the
=reflect.Value= it's easy to get to the =reflect.Type=, but let's keep the Value
and Type concepts separate for now.)

Let's start with TypeOf:

#+BEGIN_SRC go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 3.4
    fmt.Println("type:", reflect.TypeOf(x)
}
#+END_SRC

This program prints

#+BEGIN_SRC shell
type: float64
#+END_SRC

You might be wondering where the interface is here, since the program looks like
it's passing the float64 variable x, not an interface value, to reflect.TypeOf.
But it's there; as godoc reports, the signature of reflect.TypeOf includes an
empty interface:

#+BEGIN_SRC go
// TypeOf returns the reflection Type of the value in the interface{}.
func TypeOf(i interface{}) Type
#+END_SRC

When we call reflect.TypeOf(x), x is first stored in an empty interface, which
is then passed as the argument; reflect.TypeOf unpacks that empty interface to
recover the type information.

The reflect.ValueOf function, of course, recovers the value (from here on we'll
elide the boilerplate and focus just on the executable code):

#+BEGIN_SRC go
var x float64 = 3.4
fmt.Println("value:", reflect.ValueOf(x).String())
#+END_SRC

prints

#+BEGIN_SRC shell
value: <float64 Value>
#+END_SRC

(We call the String method explicitly because by default the fmt package digs
into a reflect.Value to show the concrete value inside. The String method does
not.)

Both reflect.Type and reflect.Value have lots of methods to let us examine and
manipulate them. One important example is that Value has a Type method that
returns the Type of a reflect.Value. Another is that both Type and Value have a
Kind method that returns a constant indicating what sort of item is stored:
Uint, Float64, Slice, and so on. Also methods on Value with names like Int and
Float let us grab values (as int64 and float64) stored inside:

#+BEGIN_SRC go
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())
fmt.Println("kind is float64:", v.Kind() == reflect.Float64)
fmt.Println("value:", v.Float())
#+END_SRC

prints

#+BEGIN_SRC shell
type: float64
kind is float64: true
value: 3.4
#+END_SRC

There are also methods like SetInt and SetFloat but to use them we need to
understand settability, the subject of the third law of reflection, discussed
below.

The reflection library has a couple of properties worth singling out. First, to
keep the API simple, the "getter" and "setter" methods of Value operate on the
largest type that can hold the value: int64 for all the signed integers, for
instance. That is, the Int method of Value returns an int64 and the SetInt value
takes an int64; it may be necessary to convert to the actual type involved:

#+BEGIN_SRC go
var x uint8 = 'x'
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())                            // uint8.
fmt.Println("kind is uint8: ", v.Kind() == reflect.Uint8) // true.
x = uint8(v.Uint())                                       // v.Uint returns a uint64.
#+END_SRC

The second property is that the Kind of a reflection object describes the
underlying type, not the static type. If a reflection object contains a value of
a user-defined integer type, as in

#+BEGIN_SRC go
type MyInt int
var x MyInt = 7
v := reflect.ValueOf(x)
#+END_SRC

the Kind of v is still reflect.Int, even though the static type of x is MyInt,
not int. In other words, the Kind cannot discriminate an int from a MyInt even
though the Type can.

* Reflection goes from reflection object to interface value

Like physical reflection, reflection in Go generates its own inverse.

Given a reflect.Value we can recover an interface value using the Interface
method; in effect the method packs the type and value information back into an
interface representation and returns the result:

#+BEGIN_SRC go
// Interface returns v's value as an interface{}.
func (v Value) Interface() interface{}
#+END_SRC

As a consequence we can say

#+BEGIN_SRC go
y := v.Interface().(float64) // y will have type float64.
fmt.Println(y)
#+END_SRC

to print the float64 value represented by the reflection object v.

We can do even better, though. The arguments to fmt.Println, fmt.Printf and so
on are all passed as empty interface values, which are then unpacked by the fmt
package internally just as we have been doing in the previous examples.
Therefore all it takes to print the contents of a reflect.Value correctly is to
pass the result of the Interface method to the formatted print routine:

#+BEGIN_SRC go
fmt.Println(v.Interface())
#+END_SRC

(Why not fmt.Println(v)? Because v is a reflect.Value; we want the concrete
value it holds.) Since our value is a float64, we can even use a floating-point
format if we want:

#+BEGIN_SRC go
fmt.Printf("value is %7.1e\n", v.Interface())
#+END_SRC

and get in this case

#+BEGIN_SRC shell
3.4e+00
#+END_SRC

Again, there's no need to type-assert the result of v.Interface() to float64;
the empty interface value has the concrete value's type information inside and
Printf will recover it.

In short, the Interface method is the inverse of the ValueOf function, except
that its result is always of static type interface{}.

Reiterating: Reflection goes from interface values to reflection objects and
back again.

* To modify a reflection object, the value must be settable

The third law is the most subtle and confusing, but it's easy enough to
understand if we start from first principles.

Here is some code that does not work, but is worth studying.

#+BEGIN_SRC go
var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.
#+END_SRC

If you run this code, it will panic with the cryptic message

#+BEGIN_SRC shell
panic: reflect.Value.SetFloat using unaddressable value
#+END_SRC

The problem is not that the value 7.1 is not addressable; it's that v is not
settable. Settability is a property of a reflection Value, and not all
reflection Values have it.

The CanSet method of Value reports the settability of a Value; in our case,

#+BEGIN_SRC go
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("settability of v:", v.CanSet())
#+END_SRC

prints

#+BEGIN_SRC shell
settability of v: false
#+END_SRC

It is an error to call a Set method on an non-settable Value. But what is
settability?

Settability is a bit like addressability, but stricter. It's the property that a
reflection object can modify the actual storage that was used to create the
reflection object. Settability is determined by whether the reflection object
holds the original item. When we say

#+BEGIN_SRC go
var x float64 = 3.4
v := reflect.ValueOf(x)
#+END_SRC

we pass a copy of x to reflect.ValueOf, so the interface value created as the
argument to reflect.ValueOf is a copy of x, not x itself. Thus, if the statement

#+BEGIN_SRC go
v.SetFloat(7.1)
#+END_SRC

were allowed to succeed, it would not update x, even though v looks like it was
created from x. Instead, it would update the copy of x stored inside the
reflection value and x itself would be unaffected. That would be confusing and
useless, so it is illegal, and settability is the property used to avoid this
issue.

If this seems bizarre, it's not. It's actually a familiar situation in unusual
garb. Think of passing x to a function:

#+BEGIN_SRC go
f(x)
#+END_SRC

We would not expect f to be able to modify x because we passed a copy of x's
value, not x itself. If we want f to modify x directly we must pass our function
the address of x (that is, a pointer to x):

#+BEGIN_SRC go
f(&x)
#+END_SRC

This is straightforward and familiar, and reflection works the same way. If we
want to modify x by reflection, we must give the reflection library a pointer to
the value we want to modify.

Let's do that. First we initialize x as usual and then create a reflection value
that points to it, called p.

#+BEGIN_SRC go
var x float64 = 3.4
p := reflect.ValueOf(&x) // Note: take the address of x.
fmt.Println("type of p:", p.Type())
fmt.Println("settability of p:", p.CanSet())
#+END_SRC

The output so far is

#+BEGIN_SRC shell
type of p: *float64
settability of p: false
#+END_SRC

The reflection object p isn't settable, but it's not p we want to set, it's (in
effect) *p. To get to what p points to, we call the Elem method of Value, which
indirects through the pointer, and save the result in a reflection Value called
v:

#+BEGIN_SRC go
v := p.Elem()
fmt.Println("settability of v:", v.CanSet())
#+END_SRC

Now v is a settable reflection object, as the output demonstrates,

#+BEGIN_SRC go
settability of v: true
#+END_SRC

and since it represents x, we are finally able to use v.SetFloat to modify the
value of x:

#+BEGIN_SRC go
v.SetFloat(7.1)
fmt.Println(v.Interface())
fmt.Println(x)
#+END_SRC

The output, as expected, is

#+BEGIN_SRC shell
7.1
7.1
#+END_SRC

Reflection can be hard to understand but it's doing exactly what the language
does, albeit through reflection Types and Values that can disguise what's going
on. Just keep in mind that reflection Values need the address of something in
order to modify what they represent.

** Structs

In our previous example v wasn't a pointer itself, it was just derived from one.
A common way for this situation to arise is when using reflection to modify the
fields of a structure. As long as we have the address of the structure, we can
modify its fields.

Here's a simple example that analyzes a struct value, t. We create the
reflection object with the address of the struct because we'll want to modify it
later. Then we set typeOfT to its type and iterate over the fields using
straightforward method calls (see package reflect for details). Note that we
extract the names of the fields from the struct type, but the fields themselves
are regular reflect.Value objects.

#+BEGIN_SRC go
type T struct {
    A int
    B string
}
t := T{23, "skidoo"}
s := reflect.ValueOf(&t).Elem()
typeOfT := s.Type()
for i := 0; i < s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf("%d: %s %s = %v\n", i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
}
#+END_SRC

The output of this program is

#+BEGIN_SRC shell
0: A int = 23
1: B string = skidoo
#+END_SRC

There's one more point about settability introduced in passing here: the field
names of T are upper case (exported) because only exported fields of a struct
are settable.

Because s contains a settable reflection object, we can modify the fields of the
structure.

#+BEGIN_SRC go
s.Field(0).SetInt(77)
s.Field(1).SetString("Sunset Strip")
fmt.Println("t is now", t)
#+END_SRC

And here's the result:

#+BEGIN_SRC go
t is now {77 Sunset Strip}
#+END_SRC

If we modified the program so that s was created from t, not &t, the calls to
SetInt and SetString would fail as the fields of t would not be settable.
