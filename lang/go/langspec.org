#+TITLE: The Go Programming Language Specification
#+AUTHOR: p@ctriple.cn

* The Go Programming Language Specification :TOC_4_gh:noexport:
- [[#introduction][Introduction]]
- [[#notation][Notation]]
- [[#source-code-representation][Source code representation]]
  - [[#characters][Characters]]
  - [[#letters-and-digits][Letters and digits]]
- [[#lexical-elements][Lexical elements]]
  - [[#comments][Comments]]
  - [[#tokens][Tokens]]
  - [[#semicolons][Semicolons]]
  - [[#identifiers][Identifiers]]
  - [[#keywords][Keywords]]
  - [[#operators-and-punctuation][Operators and punctuation]]
  - [[#integer-literals][Integer literals]]
  - [[#floating-point-literals][Floating-point literals]]
  - [[#imaginary-literals][Imaginary literals]]
  - [[#rune-literals][Rune literals]]
  - [[#string-literals][String literals]]
  - [[#constants][Constants]]
  - [[#variables][Variables]]
  - [[#types][Types]]
  - [[#method-sets][Method sets]]
  - [[#boolean-types][Boolean types]]
  - [[#numeric-types][Numeric types]]
  - [[#string-types][String types]]
  - [[#array-types][Array types]]
  - [[#slice-types][Slice types]]
  - [[#struct-types][Struct types]]
  - [[#pointer-types][Pointer types]]
  - [[#function-types][Function types]]
  - [[#interface-types][Interface types]]
  - [[#map-types][Map types]]
  - [[#channel-types][Channel types]]
- [[#properties-of-types-and-values][Properties of types and values]]
  - [[#type-identity][Type identity]]
  - [[#assignability][Assignability]]
- [[#blocks][Blocks]]
- [[#declarations-and-scope][Declarations and scope]]
  - [[#label-scopes][Label scopes]]
  - [[#blank-identifier][Blank identifier]]
  - [[#predeclared-identifiers][Predeclared identifiers]]
  - [[#exported-identifiers][Exported identifiers]]
  - [[#uniqueness-of-identifiers][Uniqueness of identifiers]]
  - [[#constant-declarations][Constant declarations]]
  - [[#iota][Iota]]
  - [[#type-declarations][Type declarations]]
    - [[#alias-declaration][Alias declaration]]
    - [[#type-definitions][Type definitions]]
  - [[#variable-declarations][Variable declarations]]
  - [[#short-variable-declarations][Short variable declarations]]
  - [[#function-declarations][Function declarations]]
  - [[#method-declarations][Method declarations]]
- [[#expressions][Expressions]]
  - [[#operands][Operands]]
  - [[#qualified-identifiers][Qualified identifiers]]
  - [[#composite-literals][Composite literals]]
  - [[#function-literals][Function literals]]
  - [[#primary-expressions][Primary expressions]]
  - [[#selectors][Selectors]]
  - [[#method-expressions][Method expressions]]
  - [[#method-values][Method values]]
  - [[#index-expressions][Index expressions]]
  - [[#slice-expressions][Slice expressions]]
    - [[#simple-slice-expressions][Simple slice expressions]]
    - [[#full-slice-expressions][Full slice expressions]]
  - [[#type-assertions][Type assertions]]
  - [[#calls][Calls]]
  - [[#passing-arguments-to--parameters][Passing arguments to ... parameters]]
  - [[#operators][Operators]]
    - [[#operator-precedence][Operator precedence]]
  - [[#arithmetic-operators][Arithmetic operators]]
    - [[#integer-operators][Integer operators]]
    - [[#integer-overflow][Integer overflow]]
    - [[#floating-point-operators][Floating-point operators]]
    - [[#string-concatenation][String concatenation]]
  - [[#comparison-operators][Comparison operators]]
  - [[#logical-operators][Logical operators]]
  - [[#address-operators][Address operators]]
  - [[#receive-operator][Receive operator]]
  - [[#conversions][Conversions]]
    - [[#conversions-between-numeric-types][Conversions between numeric types]]
    - [[#conversions-to-and-from-a-string-type][Conversions to and from a string type]]
  - [[#constant-expressions][Constant expressions]]
  - [[#order-of-evaluation][Order of evaluation]]

* Introduction

This is a reference manual for the Go programming language. For more information
and other documents, see [[url:https://golang.org][golang.org]].

Go is a general-purpose language designed with systems programming in mind. It
is strongly typed and garbage-collected and has explicit support for concurrent
programming. Programs are constructed from packages, whose properties allow
efficient management of dependencies. The existing implementations use a
traditional compile/link model to generate executable binaries.

The grammar is compact and regular, allowing for easy analysis by automatic
tools such as integrated development environments.

* Notation

The syntax is specified using Extended Backus-Naur Form (EBNF):

#+BEGIN_SRC text
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
#+END_SRC

Productions are expressions constructed from terms and the following operators,
in increasing precedence:

#+BEGIN_SRC text
|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
#+END_SRC

Lower-case production names are used to identify lexical tokens. Non-terminals
are in CamelCase. Lexical tokens are enclosed in double quotes "" or back quotes
``.

The form a … b represents the set of characters from a through b as
alternatives. The horizontal ellipsis … is also used elsewhere in the spec to
informally denote various enumerations or code snippets that are not further
specified. The character … (as opposed to the three characters ...) is not a
token of the Go language.

* Source code representation

Source code is Unicode text encoded in UTF-8. The text is not canonicalized, so
a single accented code point is distinct from the same character constructed
from combining an accent and a letter; those are treated as two code points. For
simplicity, this document will use the unqualified term character to refer to a
Unicode code point in the source text.

Each code point is distinct; for instance, upper and lower case letters are
different characters.

Implementation restriction: For compatibility with other tools, a compiler may
disallow the NUL character (U+0000) in the source text.

Implementation restriction: For compatibility with other tools, a compiler may
ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code
point in the source text. A byte order mark may be disallowed anywhere else in
the source.

** Characters

The following terms are used to denote specific Unicode character classes:

#+BEGIN_SRC text
newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as "Letter" */ .
unicode_digit  = /* a Unicode code point classified as "Number, decimal digit" */ .
#+END_SRC

In The Unicode Standard 8.0, Section 4.5 "General Category" defines a set of
character categories. Go treats all characters in any of the Letter categories
Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as
Unicode digits.

** Letters and digits

The underscore character _ (U+005F) is considered a letter.

#+BEGIN_SRC text
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
#+END_SRC

* Lexical elements

** Comments

Comments serve as program documentation. There are two forms:

1. Line comments start with the character sequence // and stop at the end of the line.
2. General comments start with the character sequence /* and stop with the first subsequent character sequence */.

A comment cannot start inside a rune or string literal, or inside a comment. A
general comment containing no newlines acts like a space. Any other comment acts
like a newline.

** Tokens

Tokens form the vocabulary of the Go language. There are four classes:
identifiers, keywords, operators and punctuation, and literals. White space,
formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns
(U+000D), and newlines (U+000A), is ignored except as it separates tokens that
would otherwise combine into a single token. Also, a newline or end of file may
trigger the insertion of a semicolon. While breaking the input into tokens, the
next token is the longest sequence of characters that form a valid token.

** Semicolons

The formal grammar uses semicolons ";" as terminators in a number of
productions. Go programs may omit most of these semicolons using the following
two rules:

1. When the input is broken into tokens, a semicolon is automatically inserted
   into the token stream immediately after a line's final token if that token is

    1) an identifier
    2) an integer, floating-point, imaginary, rune, or string literal
    3) one of the keywords break, continue, fallthrough, or return
    4) one of the operators and punctuation ++, --, ), ], or }

2. To allow complex statements to occupy a single line, a semicolon may be
   omitted before a closing ")" or "}".

To reflect idiomatic use, code examples in this document elide semicolons using
these rules.

** Identifiers

Identifiers name program entities such as variables and types. An identifier is
a sequence of one or more letters and digits. The first character in an
identifier must be a letter.

#+BEGIN_SRC text
identifier = letter { letter | unicode_digit } .
#+END_SRC

#+BEGIN_SRC text
a
_x9
ThisVariableIsExported
αβ
#+END_SRC

Some identifiers are predeclared.

** Keywords

The following keywords are reserved and may not be used as identifiers.

#+BEGIN_SRC text
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
#+END_SRC

** Operators and punctuation

The following character sequences represent operators (including assignment
operators) and punctuation:

#+BEGIN_SRC go
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
^    *     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=
#+END_SRC

** Integer literals

An integer literal is a sequence of digits representing an integer constant. An
optional prefix sets a non-decimal base: 0 for octal, 0x or 0X for hexadecimal.
In hexadecimal literals, letters a-f and A-F represent values 10 through 15.

#+BEGIN_SRC text
int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( "1" … "9" ) { decimal_digit } .
octal_lit   = "0" { octal_digit } .
hex_lit     = "0" ( "x" | "X" ) hex_digit { hex_digit } .
#+END_SRC

#+BEGIN_SRC text
42
0600
0xBadFace
170141183460469231731687303715884105727
#+END_SRC

** Floating-point literals

A floating-point literal is a decimal representation of a floating-point
constant. It has an integer part, a decimal point, a fractional part, and an
exponent part. The integer and fractional part comprise decimal digits; the
exponent part is an e or E followed by an optionally signed decimal exponent.
One of the integer part or the fractional part may be elided; one of the decimal
point or the exponent may be elided.

#+BEGIN_SRC text
float_lit = decimals "." [ decimals ] [ exponent ] |
            decimals exponent |
            "." decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals .
#+END_SRC

#+BEGIN_SRC text
0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
#+END_SRC

** Imaginary literals

An imaginary literal is a decimal representation of the imaginary part of a
complex constant. It consists of a floating-point literal or decimal integer
followed by the lower-case letter i.

#+BEGIN_SRC text
imaginary_lit = (decimals | float_lit) "i" .
#+END_SRC

#+BEGIN_SRC text
0i
011i  // == 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
#+END_SRC

** Rune literals

A rune literal represents a rune constant, an integer value identifying a
Unicode code point. A rune literal is expressed as one or more characters
enclosed in single quotes, as in 'x' or '\n'. Within the quotes, any character
may appear except newline and unescaped single quote. A single quoted character
represents the Unicode value of the character itself, while multi-character
sequences beginning with a backslash encode values in various formats.

The simplest form represents the single character within the quotes; since Go
source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes
may represent a single integer value. For instance, the literal 'a' holds a
single byte representing a literal a, Unicode U+0061, value 0x61, while 'ä'
holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value
0xe4.

Several backslash escapes allow arbitrary values to be encoded as ASCII text.
There are four ways to represent the integer value as a numeric constant: \x
followed by exactly two hexadecimal digits; \u followed by exactly four
hexadecimal digits; \U followed by exactly eight hexadecimal digits, and a plain
backslash \ followed by exactly three octal digits. In each case the value of
the literal is the value represented by the digits in the corresponding base.

Although these representations all result in an integer, they have different
valid ranges. Octal escapes must represent a value between 0 and 255 inclusive.
Hexadecimal escapes satisfy this condition by construction. The escapes \u and
\U represent Unicode code points so within them some values are illegal, in
particular those above 0x10FFFF and surrogate halves.

After a backslash, certain single-character escapes represent special values:

#+BEGIN_SRC text
\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within rune literals)
\"   U+0022 double quote  (valid escape only within string literals)
#+END_SRC

All other sequences starting with a backslash are illegal inside rune literals.

#+BEGIN_SRC text
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
#+END_SRC

#+BEGIN_SRC text
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // rune literal containing single quote character
'aa'         // illegal: too many characters
'\xa'        // illegal: too few hexadecimal digits
'\0'         // illegal: too few octal digits
'\uDFFF'     // illegal: surrogate half
'\U00110000' // illegal: invalid Unicode code point
#+END_SRC

** String literals

A string literal represents a string constant obtained from concatenating a
sequence of characters. There are two forms: raw string literals and interpreted
string literals.

Raw string literals are character sequences between back quotes, as in `foo`.
Within the quotes, any character may appear except back quote. The value of a
raw string literal is the string composed of the uninterpreted (implicitly
UTF-8-encoded) characters between the quotes; in particular, backslashes have no
special meaning and the string may contain newlines. Carriage return characters
('\r') inside raw string literals are discarded from the raw string value.

Interpreted string literals are character sequences between double quotes, as in
"bar". Within the quotes, any character may appear except newline and unescaped
double quote. The text between the quotes forms the value of the literal, with
backslash escapes interpreted as they are in rune literals (except that \' is
illegal and \" is legal), with the same restrictions. The three-digit octal
(\nnn) and two-digit hexadecimal (\xnn) escapes represent individual bytes of
the resulting string; all other escapes represent the (possibly multi-byte)
UTF-8 encoding of individual characters. Thus inside a string literal \377 and
\xFF represent a single byte of value 0xFF=255, while ÿ, \u00FF, \U000000FF and
\xc3\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character
U+00FF.

#+BEGIN_SRC text
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
#+END_SRC

#+BEGIN_SRC text
`abc`                // same as "abc"
`\n
\n`                  // same as "\\n\n\\n"
"\n"
"\""                 // same as `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // illegal: surrogate half
"\U00110000"         // illegal: invalid Unicode code point
#+END_SRC

These examples all represent the same string:

#+BEGIN_SRC text
"日本語"                                 // UTF-8 input text
`日本語`                                 // UTF-8 input text as a raw literal
"\u65e5\u672c\u8a9e"                    // the explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // the explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // the explicit UTF-8 bytes
#+END_SRC

If the source code represents a character as two code points, such as a
combining form involving an accent and a letter, the result will be an error if
placed in a rune literal (it is not a single code point), and will appear as two
code points if placed in a string literal.

** Constants

There are boolean constants, rune constants, integer constants, floating-point
constants, complex constants, and string constants. Rune, integer,
floating-point, and complex constants are collectively called numeric constants.

A constant value is represented by a rune, integer, floating-point, imaginary,
or string literal, an identifier denoting a constant, a constant expression, a
conversion with a result that is a constant, or the result value of some
built-in functions such as unsafe.Sizeof applied to any value, cap or len
applied to some expressions, real and imag applied to a complex constant and
complex applied to numeric constants. The boolean truth values are represented
by the predeclared constants true and false. The predeclared identifier iota
denotes an integer constant.

In general, complex constants are a form of constant expression and are
discussed in that section.

Numeric constants represent exact values of arbitrary precision and do not
overflow. Consequently, there are no constants denoting the IEEE-754 negative
zero, infinity, and not-a-number values.

Constants may be typed or untyped. Literal constants, true, false, iota, and
certain constant expressions containing only untyped constant operands are
untyped.

A constant may be given a type explicitly by a constant declaration or
conversion, or implicitly when used in a variable declaration or an assignment
or as an operand in an expression. It is an error if the constant value cannot
be represented as a value of the respective type. For instance, 3.0 can be given
any integer or any floating-point type, while 2147483648.0 (equal to 1<<31) can
be given the types float32, float64, or uint32 but not int32 or string.

An untyped constant has a default type which is the type to which the constant
is implicitly converted in contexts where a typed value is required, for
instance, in a short variable declaration such as i := 0 where there is no
explicit type. The default type of an untyped constant is bool, rune, int,
float64, complex128 or string respectively, depending on whether it is a
boolean, rune, integer, floating-point, complex, or string constant.

Implementation restriction: Although numeric constants have arbitrary precision
in the language, a compiler may implement them using an internal representation
with limited precision. That said, every implementation must:

    1) Represent integer constants with at least 256 bits.
    2) Represent floating-point constants, including the parts of a complex
       constant, with a mantissa of at least 256 bits and a signed binary
       exponent of at least 16 bits.
    3) Give an error if unable to represent an integer constant precisely.
    4) Give an error if unable to represent a floating-point or complex constant
       due to overflow.
    5) Round to the nearest representable constant if unable to represent a
       floating-point or complex constant due to limits on precision.

These requirements apply both to literal constants and to the result of
evaluating constant expressions.

** Variables

A variable is a storage location for holding a value. The set of permissible
values is determined by the variable's type.

A variable declaration or, for function parameters and results, the signature of
a function declaration or function literal reserves storage for a named
variable. Calling the built-in function new or taking the address of a composite
literal allocates storage for a variable at run time. Such an anonymous variable
is referred to via a (possibly implicit) pointer indirection.

Structured variables of array, slice, and struct types have elements and fields
that may be addressed individually. Each such element acts like a variable.

The static type (or just type) of a variable is the type given in its
declaration, the type provided in the new call or composite literal, or the type
of an element of a structured variable. Variables of interface type also have a
distinct dynamic type, which is the concrete type of the value assigned to the
variable at run time (unless the value is the predeclared identifier nil, which
has no type). The dynamic type may vary during execution but values stored in
interface variables are always assignable to the static type of the variable.

#+BEGIN_SRC text
var x interface{}  // x is nil and has static type interface{}
var v *T           // v has value nil, static type *T
x = 42             // x has value 42 and dynamic type int
x = v              // x has value (*T)(nil) and dynamic type *T
#+END_SRC

A variable's value is retrieved by referring to the variable in an expression;
it is the most recent value assigned to the variable. If a variable has not yet
been assigned a value, its value is the zero value for its type.

** Types

A type determines a set of values together with operations and methods specific
to those values. A type may be denoted by a type name, if it has one, or
specified using a type literal, which composes a type from existing types.

#+BEGIN_SRC text
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType .
#+END_SRC

Named instances of the boolean, numeric, and string types are predeclared. Other
named types are introduced with type declarations. Composite types—array,
struct, pointer, function, interface, slice, map, and channel types—may be
constructed using type literals.

Each type T has an underlying type: If T is one of the predeclared boolean,
numeric, or string types, or a type literal, the corresponding underlying type
is T itself. Otherwise, T's underlying type is the underlying type of the type
to which T refers in its type declaration.

#+BEGIN_SRC go
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)
#+END_SRC

The underlying type of string, A1, A2, B1, and B2 is string. The underlying type
of []B1, B3, and B4 is []B1.

** Method sets

A type may have a method set associated with it. The method set of an interface
type is its interface. The method set of any other type T consists of all
methods declared with receiver type T. The method set of the corresponding
pointer type *T is the set of all methods declared with receiver *T or T (that
is, it also contains the method set of T). Further rules apply to structs
containing embedded fields, as described in the section on struct types. Any
other type has an empty method set. In a method set, each method must have a
unique non-blank method name.

The method set of a type determines the interfaces that the type implements and
the methods that can be called using a receiver of that type.

** Boolean types

A boolean type represents the set of Boolean truth values denoted by the
predeclared constants true and false. The predeclared boolean type is bool.

** Numeric types

A numeric type represents sets of integer or floating-point values. The
predeclared architecture-independent numeric types are:

#+BEGIN_SRC text
uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
#+END_SRC

The value of an n-bit integer is n bits wide and represented using two's
complement arithmetic.

There is also a set of predeclared numeric types with implementation-specific
sizes:

#+BEGIN_SRC text
uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
#+END_SRC

To avoid portability issues all numeric types are distinct except byte, which is
an alias for uint8, and rune, which is an alias for int32. Conversions are
required when different numeric types are mixed in an expression or assignment.
For instance, int32 and int are not the same type even though they may have the
same size on a particular architecture.

** String types

A string type represents the set of string values. A string value is a (possibly
empty) sequence of bytes. Strings are immutable: once created, it is impossible
to change the contents of a string. The predeclared string type is string.

The length of a string s (its size in bytes) can be discovered using the
built-in function len. The length is a compile-time constant if the string is a
constant. A string's bytes can be accessed by integer indices 0 through
len(s)-1. It is illegal to take the address of such an element; if s[i] is the
i'th byte of a string, &s[i] is invalid.

** Array types

An array is a numbered sequence of elements of a single type, called the element
type. The number of elements is called the length and is never negative.

#+BEGIN_SRC text
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
#+END_SRC

The length is part of the array's type; it must evaluate to a non-negative
constant representable by a value of type int. The length of array a can be
discovered using the built-in function len. The elements can be addressed by
integer indices 0 through len(a)-1. Array types are always one-dimensional but
may be composed to form multi-dimensional types.

#+BEGIN_SRC text
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
#+END_SRC

** Slice types

A slice is a descriptor for a contiguous segment of an underlying array and
provides access to a numbered sequence of elements from that array. A slice type
denotes the set of all slices of arrays of its element type. The value of an
uninitialized slice is nil.

#+BEGIN_SRC text
SliceType = "[" "]" ElementType .
#+END_SRC

Like arrays, slices are indexable and have a length. The length of a slice s can
be discovered by the built-in function len; unlike with arrays it may change
during execution. The elements can be addressed by integer indices 0 through
len(s)-1. The slice index of a given element may be less than the index of the
same element in the underlying array.

A slice, once initialized, is always associated with an underlying array that
holds its elements. A slice therefore shares storage with its array and with
other slices of the same array; by contrast, distinct arrays always represent
distinct storage.

The array underlying a slice may extend past the end of the slice. The capacity
is a measure of that extent: it is the sum of the length of the slice and the
length of the array beyond the slice; a slice of length up to that capacity can
be created by slicing a new one from the original slice. The capacity of a slice
a can be discovered using the built-in function cap(a).

A new, initialized slice value for a given element type T is made using the
built-in function make, which takes a slice type and parameters specifying the
length and optionally the capacity. A slice created with make always allocates a
new, hidden array to which the returned slice value refers. That is, executing

#+BEGIN_SRC go
make([]T, length, capacity)
#+END_SRC

produces the same slice as allocating an array and slicing it, so these two
expressions are equivalent:

#+BEGIN_SRC go
make([]int, 50, 100)
new([100]int)[0:50]
#+END_SRC

Like arrays, slices are always one-dimensional but may be composed to construct
higher-dimensional objects. With arrays of arrays, the inner arrays are, by
construction, always the same length; however with slices of slices (or arrays
of slices), the inner lengths may vary dynamically. Moreover, the inner slices
must be initialized individually.

** Struct types

A struct is a sequence of named elements, called fields, each of which has a
name and a type. Field names may be specified explicitly (IdentifierList) or
implicitly (EmbeddedField). Within a struct, non-blank field names must be
unique.

#+BEGIN_SRC text
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit .
#+END_SRC

#+BEGIN_SRC go
// An empty struct.
struct {}

// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
#+END_SRC

A field declared with a type but no explicit field name is called an embedded
field. An embedded field must be specified as a type name T or as a pointer to a
non-interface type name *T, and T itself may not be a pointer type. The
unqualified type name acts as the field name.

#+BEGIN_SRC go
// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}
#+END_SRC

The following declaration is illegal because field names must be unique in a
struct type:

#+BEGIN_SRC go
struct {
	T     // conflicts with embedded field *T and *P.T
	*T    // conflicts with embedded field T and *P.T
	*P.T  // conflicts with embedded field T and *T
}
#+END_SRC

A field or method f of an embedded field in a struct x is called promoted if x.f
is a legal selector that denotes that field or method f.

Promoted fields act like ordinary fields of a struct except that they cannot be
used as field names in composite literals of the struct.

Given a struct type S and a type named T, promoted methods are included in the
method set of the struct as follows:

    1) If S contains an embedded field T, the method sets of S and *S both
       include promoted methods with receiver T. The method set of *S also
       includes promoted methods with receiver *T.
    2) If S contains an embedded field *T, the method sets of S and *S both
       include promoted methods with receiver T or *T.

A field declaration may be followed by an optional string literal tag, which
becomes an attribute for all the fields in the corresponding field declaration.
An empty tag string is equivalent to an absent tag. The tags are made visible
through a reflection interface and take part in type identity for structs but
are otherwise ignored.

#+BEGIN_SRC go
struct {
	x, y float64 ""  // an empty tag string is like an absent tag
	name string  "any string is permitted as a tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// A struct corresponding to a TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers;
// they follow the convention outlined by the reflect package.
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
#+END_SRC

** Pointer types

A pointer type denotes the set of all pointers to variables of a given type,
called the base type of the pointer. The value of an uninitialized pointer is
nil.

#+BEGIN_SRC text
PointerType = "*" BaseType .
BaseType    = Type .
#+END_SRC

#+BEGIN_SRC go
*Point
*[4]int
#+END_SRC

** Function types

A function type denotes the set of all functions with the same parameter and
result types. The value of an uninitialized variable of function type is nil.

#+BEGIN_SRC text
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
#+END_SRC

Within a list of parameters or results, the names (IdentifierList) must either
all be present or all be absent. If present, each name stands for one item
(parameter or result) of the specified type and all non-blank names in the
signature must be unique. If absent, each type stands for one item of that type.
Parameter and result lists are always parenthesized except that if there is
exactly one unnamed result it may be written as an unparenthesized type.

The final incoming parameter in a function signature may have a type prefixed
with .... A function with such a parameter is called variadic and may be invoked
with zero or more arguments for that parameter.

#+BEGIN_SRC go
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
#+END_SRC

** Interface types

An interface type specifies a method set called its interface. A variable of
interface type can store a value of any type with a method set that is any
superset of the interface. Such a type is said to implement the interface. The
value of an uninitialized variable of interface type is nil.

#+BEGIN_SRC text
InterfaceType      = "interface" "{" { MethodSpec ";" } "}" .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
#+END_SRC

As with all method sets, in an interface type, each method must have a unique
non-blank name.

#+BEGIN_SRC go
// A simple File interface
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
#+END_SRC

More than one type may implement an interface. For instance, if two types S1 and
S2 have the method set

#+BEGIN_SRC go
func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }
#+END_SRC

(where T stands for either S1 or S2) then the File interface is implemented by
both S1 and S2, regardless of what other methods S1 and S2 may have or share.

A type implements any interface comprising any subset of its methods and may
therefore implement several distinct interfaces. For instance, all types
implement the empty interface:

#+BEGIN_SRC go
interface{}
#+END_SRC

Similarly, consider this interface specification, which appears within a type
declaration to define an interface called Locker:

#+BEGIN_SRC go
type Locker interface {
	Lock()
	Unlock()
}
#+END_SRC

If S1 and S2 also implement

#+BEGIN_SRC go
func (p T) Lock() { … }
func (p T) Unlock() { … }
#+END_SRC

they implement the Locker interface as well as the File interface.

An interface T may use a (possibly qualified) interface type name E in place of
a method specification. This is called embedding interface E in T; it adds all
(exported and non-exported) methods of E to the interface T.

#+BEGIN_SRC go
type ReadWriter interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
}

type File interface {
	ReadWriter  // same as adding the methods of ReadWriter
	Locker      // same as adding the methods of Locker
	Close()
}

type LockedFile interface {
	Locker
	File        // illegal: Lock, Unlock not unique
	Lock()      // illegal: Lock not unique
}
#+END_SRC

An interface type T may not embed itself or any interface type that embeds T,
recursively.

#+BEGIN_SRC go
// illegal: Bad cannot embed itself
type Bad interface {
	Bad
}

// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
#+END_SRC

** Map types

A map is an unordered group of elements of one type, called the element type,
indexed by a set of unique keys of another type, called the key type. The value
of an uninitialized map is nil.

#+BEGIN_SRC text
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
#+END_SRC

The comparison operators == and != must be fully defined for operands of the key
type; thus the key type must not be a function, map, or slice. If the key type
is an interface type, these comparison operators must be defined for the dynamic
key values; failure will cause a run-time panic.

#+BEGIN_SRC go
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
#+END_SRC

The number of map elements is called its length. For a map m, it can be
discovered using the built-in function len and may change during execution.
Elements may be added during execution using assignments and retrieved with
index expressions; they may be removed with the delete built-in function.

A new, empty map value is made using the built-in function make, which takes the
map type and an optional capacity hint as arguments:

#+BEGIN_SRC go
make(map[string]int)
make(map[string]int, 100)
#+END_SRC

The initial capacity does not bound its size: maps grow to accommodate the
number of items stored in them, with the exception of nil maps. A nil map is
equivalent to an empty map except that no elements may be added.

** Channel types

A channel provides a mechanism for concurrently executing functions to
communicate by sending and receiving values of a specified element type. The
value of an uninitialized channel is nil.

#+BEGIN_SRC text
ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType .
#+END_SRC

The optional <- operator specifies the channel direction, send or receive. If no
direction is given, the channel is bidirectional. A channel may be constrained
only to send or only to receive by conversion or assignment.

#+BEGIN_SRC go
chan T          // can be used to send and receive values of type T
chan<- float64  // can only be used to send float64s
<-chan int      // can only be used to receive ints
#+END_SRC

The <- operator associates with the leftmost chan possible:

#+BEGIN_SRC go
chan<- chan int    // same as chan<- (chan int)
chan<- <-chan int  // same as chan<- (<-chan int)
<-chan <-chan int  // same as <-chan (<-chan int)
chan (<-chan int)
#+END_SRC

A new, initialized channel value can be made using the built-in function make,
which takes the channel type and an optional capacity as arguments:

#+BEGIN_SRC go
make(chan int, 100)
#+END_SRC

The capacity, in number of elements, sets the size of the buffer in the channel.
If the capacity is zero or absent, the channel is unbuffered and communication
succeeds only when both a sender and receiver are ready. Otherwise, the channel
is buffered and communication succeeds without blocking if the buffer is not
full (sends) or not empty (receives). A nil channel is never ready for
communication.

A channel may be closed with the built-in function close. The multi-valued
assignment form of the receive operator reports whether a received value was
sent before the channel was closed.

A single channel may be used in send statements, receive operations, and calls
to the built-in functions cap and len by any number of goroutines without
further synchronization. Channels act as first-in-first-out queues. For example,
if one goroutine sends values on a channel and a second goroutine receives them,
the values are received in the order sent.

* Properties of types and values

** Type identity

Two types are either identical or different.

A defined type is always different from any other type. Otherwise, two types are
identical if their underlying type literals are structurally equivalent; that
is, they have the same literal structure and corresponding components have
identical types. In detail:

    1) Two array types are identical if they have identical element types and
       the same array length.
    2) Two slice types are identical if they have identical element types.
    3) Two struct types are identical if they have the same sequence of fields,
       and if corresponding fields have the same names, and identical types, and
       identical tags. Non-exported field names from different packages are
       always different.
    4) Two pointer types are identical if they have identical base types.
    5) Two function types are identical if they have the same number of
       parameters and result values, corresponding parameter and result types
       are identical, and either both functions are variadic or neither is.
       Parameter and result names are not required to match.
    6) Two interface types are identical if they have the same set of methods
       with the same names and identical function types. Non-exported method
       names from different packages are always different. The order of the
       methods is irrelevant.
    7) Two map types are identical if they have identical key and value types.
    8) Two channel types are identical if they have identical value types and
       the same direction.

Given the declarations

#+BEGIN_SRC go
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string
)

type (
	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1
)

type	C0 = B0
#+END_SRC

these types are identical:

#+BEGIN_SRC go
A0, A1, and []string
A2 and struct{ a, b int }
A3 and int
A4, func(int, float64) *[]string, and A5

B0, B0, and C0
[]int and []int
struct{ a, b *T5 } and struct{ a, b *T5 }
func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5
#+END_SRC

B0 and B1 are different because they are new types created by distinct type
definitions; func(int, float64) *B0 and func(x int, y float64) *[]string are
different because B0 is different from []string.

** Assignability

A value x is assignable to a variable of type T ("x is assignable to T") in any
of these cases:

    1) x's type is identical to T.
    2) x's type V and T have identical underlying types and at least one of V or
       T is not a defined type.
    3) T is an interface type and x implements T.
    4) x is a bidirectional channel value, T is a channel type, x's type V and T
       have identical element types, and at least one of V or T is not a defined
       type.
    5) x is the predeclared identifier nil and T is a pointer, function, slice,
       map, channel, or interface type.
    6) x is an untyped constant representable by a value of type T.

* Blocks

A block is a possibly empty sequence of declarations and statements within
matching brace brackets.

#+BEGIN_SRC text
Block = "{" StatementList "}" .
StatementList = { Statement ";" } .
#+END_SRC

In addition to explicit blocks in the source code, there are implicit blocks:

    1) The universe block encompasses all Go source text.
    2) Each package has a package block containing all Go source text for that
       package.
    3) Each file has a file block containing all Go source text in that file.
    4) Each "if", "for", and "switch" statement is considered to be in its own
       implicit block.
    5) Each clause in a "switch" or "select" statement acts as an implicit
       block.

Blocks nest and influence scoping.

* Declarations and scope

A declaration binds a non-blank identifier to a constant, type, variable,
function, label, or package. Every identifier in a program must be declared. No
identifier may be declared twice in the same block, and no identifier may be
declared in both the file and package block.

The blank identifier may be used like any other identifier in a declaration, but
it does not introduce a binding and thus is not declared. In the package block,
the identifier init may only be used for init function declarations, and like
the blank identifier it does not introduce a new binding.

#+BEGIN_SRC text
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
#+END_SRC

The scope of a declared identifier is the extent of source text in which the
identifier denotes the specified constant, type, variable, function, label, or
package.

Go is lexically scoped using blocks:

    1) The scope of a predeclared identifier is the universe block.
    2) The scope of an identifier denoting a constant, type, variable, or
       function (but not method) declared at top level (outside any function) is
       the package block.
    3) The scope of the package name of an imported package is the file block of
       the file containing the import declaration.
    4) The scope of an identifier denoting a method receiver, function
       parameter, or result variable is the function body.
    5) The scope of a constant or variable identifier declared inside a function
       begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short
       variable declarations) and ends at the end of the innermost containing
       block.
    6) The scope of a type identifier declared inside a function begins at the
       identifier in the TypeSpec and ends at the end of the innermost
       containing block.

An identifier declared in a block may be redeclared in an inner block. While the
identifier of the inner declaration is in scope, it denotes the entity declared
by the inner declaration.

The package clause is not a declaration; the package name does not appear in any
scope. Its purpose is to identify the files belonging to the same package and to
specify the default package name for import declarations.

** Label scopes

Labels are declared by labeled statements and are used in the "break",
"continue", and "goto" statements. It is illegal to define a label that is never
used. In contrast to other identifiers, labels are not block scoped and do not
conflict with identifiers that are not labels. The scope of a label is the body
of the function in which it is declared and excludes the body of any nested
function.

** Blank identifier

The blank identifier is represented by the underscore character _. It serves as
an anonymous placeholder instead of a regular (non-blank) identifier and has
special meaning in declarations, as an operand, and in assignments.

** Predeclared identifiers

The following identifiers are implicitly declared in the universe block:

#+BEGIN_SRC text
Types:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap close complex copy delete imag len
	make new panic print println real recover
#+END_SRC

** Exported identifiers

An identifier may be exported to permit access to it from another package. An
identifier is exported if both:

    1) the first character of the identifier's name is a Unicode upper case
       letter (Unicode class "Lu"); and
    1) the identifier is declared in the package block or it is a field name or
       method name.

All other identifiers are not exported.

** Uniqueness of identifiers

Given a set of identifiers, an identifier is called unique if it is different
from every other in the set. Two identifiers are different if they are spelled
differently, or if they appear in different packages and are not exported.
Otherwise, they are the same.

** Constant declarations

A constant declaration binds a list of identifiers (the names of the constants)
to the values of a list of constant expressions. The number of identifiers must
be equal to the number of expressions, and the nth identifier on the left is
bound to the value of the nth expression on the right.

#+BEGIN_SRC text
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
#+END_SRC

If the type is present, all constants take the type specified, and the
expressions must be assignable to that type. If the type is omitted, the
constants take the individual types of the corresponding expressions. If the
expression values are untyped constants, the declared constants remain untyped
and the constant identifiers denote the constant values. For instance, if the
expression is a floating-point literal, the constant identifier denotes a
floating-point constant, even if the literal's fractional part is zero.

#+BEGIN_SRC go
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant
const (
	size int64 = 1024
	eof        = -1  // untyped integer constant
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", untyped integer and string constants
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
#+END_SRC

Within a parenthesized const declaration list the expression list may be omitted
from any but the first declaration. Such an empty list is equivalent to the
textual substitution of the first preceding non-empty expression list and its
type if any. Omitting the list of expressions is therefore equivalent to
repeating the previous list. The number of identifiers must be equal to the
number of expressions in the previous list. Together with the iota constant
generator this mechanism permits light-weight declaration of sequential values:

#+BEGIN_SRC go
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // this constant is not exported
)
#+END_SRC

** Iota

Within a constant declaration, the predeclared identifier iota represents
successive untyped integer constants. It is reset to 0 whenever the reserved
word const appears in the source and increments after each ConstSpec. It can be
used to construct a set of related constants:

#+BEGIN_SRC go
const ( // iota is reset to 0
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const ( // iota is reset to 0
	a = 1 << iota  // a == 1
	b = 1 << iota  // b == 2
	c = 3          // c == 3  (iota is not used but still incremented)
	d = 1 << iota  // d == 8
)

const ( // iota is reset to 0
	u         = iota * 42  // u == 0     (untyped integer constant)
	v float64 = iota * 42  // v == 42.0  (float64 constant)
	w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0  (iota has been reset)
const y = iota  // y == 0  (iota has been reset)
#+END_SRC

Within an ExpressionList, the value of each iota is the same because it is only
incremented after each ConstSpec:

#+BEGIN_SRC go
const (
	bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0
	bit1, mask1                           // bit1 == 2, mask1 == 1
	_, _                                  // skips iota == 2
	bit3, mask3                           // bit3 == 8, mask3 == 7
)
#+END_SRC

This last example exploits the implicit repetition of the last non-empty
expression list.

** Type declarations

A type declaration binds an identifier, the type name, to a type. Type
declarations come in two forms: alias declarations and type definitions.

#+BEGIN_SRC text
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec = AliasDecl | TypeDef .
#+END_SRC

*** Alias declaration

An alias declaration binds an identifier to the given type.

#+BEGIN_SRC text
AliasDecl = identifier "=" Type .
#+END_SRC

Within the scope of the identifier, it serves as an alias for the type.

#+BEGIN_SRC go
type (
	nodeList = []*Node  // nodeList and []*Node are identical types
	Polar    = polar    // Polar and polar denote identical types
)
#+END_SRC

*** Type definitions

A type definition creates a new, distinct type with the same underlying type and
operations as the given type, and binds an identifier to it.

#+BEGIN_SRC text
TypeDef = identifier Type .
#+END_SRC

The new type is called a defined type. It is different from any other type,
including the type it is created from.

#+BEGIN_SRC go
type (
	Point struct{ x, y float64 }  // Point and struct{ x, y float64 } are different types
	polar Point                   // polar and Point denote different types
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
#+END_SRC

A defined type may have methods associated with it. It does not inherit any
methods bound to the given type, but the method set of an interface type or of
elements of a composite type remains unchanged:

#+BEGIN_SRC go
// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of the base type of PtrMutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its embedded field Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
#+END_SRC

Type definitions may be used to define different boolean, numeric, or string
types and associate methods with them:

#+BEGIN_SRC go
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT%+dh", tz)
}
#+END_SRC

** Variable declarations

A variable declaration creates one or more variables, binds corresponding
identifiers to them, and gives each a type and an initial value.

#+BEGIN_SRC text
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
#+END_SRC

#+BEGIN_SRC go
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in "found"
#+END_SRC

If a list of expressions is given, the variables are initialized with the
expressions following the rules for assignments. Otherwise, each variable is
initialized to its zero value.

If a type is present, each variable is given that type. Otherwise, each variable
is given the type of the corresponding initialization value in the assignment.
If that value is an untyped constant, it is first converted to its default type;
if it is an untyped boolean value, it is first converted to type bool. The
predeclared value nil cannot be used to initialize a variable with no explicit
type.

#+BEGIN_SRC go
var d = math.Sin(0.5)  // d is float64
var i = 42             // i is int
var t, ok = x.(T)      // t is T, ok is bool
var n = nil            // illegal
#+END_SRC

Implementation restriction: A compiler may make it illegal to declare a variable
inside a function body if the variable is never used.

** Short variable declarations

A short variable declaration uses the syntax:

#+BEGIN_SRC text
ShortVarDecl = IdentifierList ":=" ExpressionList .
#+END_SRC

It is shorthand for a regular variable declaration with initializer expressions
but no types:

#+BEGIN_SRC text
"var" IdentifierList = ExpressionList .
#+END_SRC

#+BEGIN_SRC go
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() returns two values
_, y, _ := coord(p)  // coord() returns three values; only interested in y coordinate
#+END_SRC

Unlike regular variable declarations, a short variable declaration may redeclare
variables provided they were originally declared earlier in the same block (or
the parameter lists if the block is the function body) with the same type, and
at least one of the non-blank variables is new. As a consequence, redeclaration
can only appear in a multi-variable short declaration. Redeclaration does not
introduce a new variable; it just assigns a new value to the original.

#+BEGIN_SRC go
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
a, a := 1, 2                              // illegal: double declaration of a or no new variable if a was declared elsewhere
#+END_SRC

Short variable declarations may appear only inside functions. In some contexts
such as the initializers for "if", "for", or "switch" statements, they can be
used to declare local temporary variables.

** Function declarations

A function declaration binds an identifier, the function name, to a function.

#+BEGIN_SRC text
FunctionDecl = "func" FunctionName ( Function | Signature ) .
FunctionName = identifier .
Function     = Signature FunctionBody .
FunctionBody = Block .
#+END_SRC

If the function's signature declares result parameters, the function body's
statement list must end in a terminating statement.

#+BEGIN_SRC go
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// invalid: missing return statement
}
#+END_SRC

A function declaration may omit the body. Such a declaration provides the
signature for a function implemented outside Go, such as an assembly routine.

#+BEGIN_SRC go
func min(x int, y int) int {
	if x < y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // implemented externally
#+END_SRC

** Method declarations

A method is a function with a receiver. A method declaration binds an
identifier, the method name, to a method, and associates the method with the
receiver's base type.

#+BEGIN_SRC text
MethodDecl = "func" Receiver MethodName ( Function | Signature ) .
Receiver   = Parameters .
#+END_SRC

The receiver is specified via an extra parameter section preceding the method
name. That parameter section must declare a single non-variadic parameter, the
receiver. Its type must be of the form T or *T (possibly using parentheses)
where T is a type name. The type denoted by T is called the receiver base type;
it must not be a pointer or interface type and it must be defined in the same
package as the method. The method is said to be bound to the base type and the
method name is visible only within selectors for type T or *T.

A non-blank receiver identifier must be unique in the method signature. If the
receiver's value is not referenced inside the body of the method, its identifier
may be omitted in the declaration. The same applies in general to parameters of
functions and methods.

For a base type, the non-blank names of methods bound to it must be unique. If
the base type is a struct type, the non-blank method and field names must be
distinct.

Given type Point, the declarations

#+BEGIN_SRC go
func (p *Point) Length() float64 {
	return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
	p.x *= factor
	p.y *= factor
}
#+END_SRC

bind the methods Length and Scale, with receiver type *Point, to the base type
Point.

The type of a method is the type of a function with the receiver as first
argument. For instance, the method Scale has type

#+BEGIN_SRC go
func(p *Point, factor float64)
#+END_SRC

However, a function declared this way is not a method.

* Expressions

An expression specifies the computation of a value by applying operators and
functions to operands.

** Operands

Operands denote the elementary values in an expression. An operand may be a
literal, a (possibly qualified) non-blank identifier denoting a constant,
variable, or function, a method expression yielding a function, or a
parenthesized expression.

The blank identifier may appear as an operand only on the left-hand side of an
assignment.

#+BEGIN_SRC text
Operand     = Literal | OperandName | MethodExpr | "(" Expression ")" .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent.
#+END_SRC

** Qualified identifiers

A qualified identifier is an identifier qualified with a package name prefix.
Both the package name and the identifier must not be blank.

#+BEGIN_SRC text
QualifiedIdent = PackageName "." identifier .
#+END_SRC

A qualified identifier accesses an identifier in a different package, which must
be imported. The identifier must be exported and declared in the package block
of that package.

#+BEGIN_SRC go
math.Sin	// denotes the Sin function in package math
#+END_SRC

** Composite literals

Composite literals construct values for structs, arrays, slices, and maps and
create a new value each time they are evaluated. They consist of the type of the
literal followed by a brace-bound list of elements. Each element may optionally
be preceded by a corresponding key.

#+BEGIN_SRC text
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = KeyedElement { "," KeyedElement } .
KeyedElement  = [ Key ":" ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
#+END_SRC

The LiteralType's underlying type must be a struct, array, slice, or map type
(the grammar enforces this constraint except when the type is given as a
TypeName). The types of the elements and keys must be assignable to the
respective field, element, and key types of the literal type; there is no
additional conversion. The key is interpreted as a field name for struct
literals, an index for array and slice literals, and a key for map literals. For
map literals, all elements must have a key. It is an error to specify multiple
elements with the same field name or constant key value. For non-constant map
keys, see the section on evaluation order.

For struct literals the following rules apply:

    1) A key must be a field name declared in the struct type.
    2) An element list that does not contain any keys must list an element for
       each struct field in the order in which the fields are declared.
    3) If any element has a key, every element must have a key.
    4) An element list that contains keys does not need to have an element for
       each struct field. Omitted fields get the zero value for that field.
    5) A literal may omit the element list; such a literal evaluates to the
       zero value for its type.
    6) It is an error to specify an element for a non-exported field of a
        struct belonging to a different package.

Given the declarations

#+BEGIN_SRC go
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
#+END_SRC

one may write

#+BEGIN_SRC go
origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
#+END_SRC

For array and slice literals the following rules apply:

    1) Each element has an associated integer index marking its position in the
       array.
    2) An element with a key uses the key as its index. The key must be a
       non-negative constant representable by a value of type int; and if it is
       typed it must be of integer type.
    3) An element without a key uses the previous element's index plus one. If
       the first element has no key, its index is zero.

Taking the address of a composite literal generates a pointer to a unique
variable initialized with the literal's value.

#+BEGIN_SRC go
var pointer *Point3D = &Point3D{y: 1000}
#+END_SRC

The length of an array literal is the length specified in the literal type. If
fewer elements than the length are provided in the literal, the missing elements
are set to the zero value for the array element type. It is an error to provide
elements with index values outside the index range of the array. The notation
... specifies an array length equal to the maximum element index plus one.

#+BEGIN_SRC go
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
#+END_SRC

A slice literal describes the entire underlying array literal. Thus the length
and capacity of a slice literal are the maximum element index plus one. A slice
literal has the form

#+BEGIN_SRC go
[]T{x1, x2, … xn}
#+END_SRC

and is shorthand for a slice operation applied to an array:

#+BEGIN_SRC go
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]
#+END_SRC

Within a composite literal of array, slice, or map type T, elements or map keys
that are themselves composite literals may elide the respective literal type if
it is identical to the element or key type of T. Similarly, elements or keys
that are addresses of composite literals may elide the &T when the element or
key type is *T.

#+BEGIN_SRC go
[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}
#+END_SRC

A parsing ambiguity arises when a composite literal using the TypeName form of
the LiteralType appears as an operand between the keyword and the opening brace
of the block of an "if", "for", or "switch" statement, and the composite literal
is not enclosed in parentheses, square brackets, or curly braces. In this rare
case, the opening brace of the literal is erroneously parsed as the one
introducing the block of statements. To resolve the ambiguity, the composite
literal must appear within parentheses.

#+BEGIN_SRC go
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
#+END_SRC

Examples of valid array, slice, and map literals:

#+BEGIN_SRC go
// list of prime numbers
primes := []int{2, 3, 5, 7, 9, 2147483647}

// vowels[ch] is true if ch is a vowel
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// frequencies in Hz for equal-tempered scale (A4 = 440Hz)
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
#+END_SRC

** Function literals

A function literal represents an anonymous function.

#+BEGIN_SRC text
FunctionLit = "func" Function .
#+END_SRC

#+BEGIN_SRC go
func(a, b int, z float64) bool { return a*b < int(z) }
#+END_SRC

A function literal can be assigned to a variable or invoked directly.

#+BEGIN_SRC go
f := func(x, y int) int { return x + y }
func(ch chan int) { ch <- ACK }(replyChan)
#+END_SRC

Function literals are closures: they may refer to variables defined in a
surrounding function. Those variables are then shared between the surrounding
function and the function literal, and they survive as long as they are
accessible.

** Primary expressions

Primary expressions are the operands for unary and binary expressions.

#+BEGIN_SRC text
PrimaryExpr =
	Operand |
	Conversion |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Arguments .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
                 "[" [ Expression ] ":" Expression ":" Expression "]" .
TypeAssertion  = "." "(" Type ")" .
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
#+END_SRC

#+BEGIN_SRC go
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()
#+END_SRC

** Selectors

For a primary expression x that is not a package name, the selector expression

#+BEGIN_SRC go
x.f
#+END_SRC

denotes the field or method f of the value x (or sometimes *x; see below). The
identifier f is called the (field or method) selector; it must not be the blank
identifier. The type of the selector expression is the type of f. If x is a
package name, see the section on qualified identifiers.

A selector f may denote a field or method f of a type T, or it may refer to a
field or method f of a nested embedded field of T. The number of embedded fields
traversed to reach f is called its depth in T. The depth of a field or method f
declared in T is zero. The depth of a field or method f declared in an embedded
field A in T is the depth of f in A plus one.

The following rules apply to selectors:

    1) For a value x of type T or *T where T is not a pointer or interface type,
       x.f denotes the field or method at the shallowest depth in T where there
       is such an f. If there is not exactly one f with shallowest depth, the
       selector expression is illegal.
    2) For a value x of type I where I is an interface type, x.f denotes the
       actual method with name f of the dynamic value of x. If there is no
       method with name f in the method set of I, the selector expression is
       illegal.
    3) As an exception, if the type of x is a named pointer type and (*x).f is a
       valid selector expression denoting a field (but not a method), x.f is
       shorthand for (*x).f.
    4) In all other cases, x.f is illegal.
    5) If x is of pointer type and has the value nil and x.f denotes a struct
       field, assigning to or evaluating x.f causes a run-time panic.
    6) If x is of interface type and has the value nil, calling or evaluating
       the method x.f causes a run-time panic.

For example, given the declarations:

#+BEGIN_SRC go
type T0 struct {
	x int
}

func (*T0) M0()

type T1 struct {
	y int
}

func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (*T2) M2()

type Q *T2

var t T2     // with t.T0 != nil
var p *T2    // with p != nil and (*p).T0 != nil
var q Q = p
#+END_SRC

one may write:

#+BEGIN_SRC go
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x is a valid field selector

p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver
p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver
p.M2()       // p.M2()              M2 expects *T2 receiver
t.M2()       // (&t).M2()           M2 expects *T2 receiver, see section on Calls
#+END_SRC

but the following is invalid:

#+BEGIN_SRC go
q.M0()       // (*q).M0 is valid but not a field selector
#+END_SRC

** Method expressions

If M is in the method set of type T, T.M is a function that is callable as a
regular function with the same arguments as M prefixed by an additional argument
that is the receiver of the method.

#+BEGIN_SRC text
MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = TypeName | "(" "*" TypeName ")" | "(" ReceiverType ")" .
#+END_SRC

Consider a struct type T with two methods, Mv, whose receiver is of type T, and
Mp, whose receiver is of type *T.

#+BEGIN_SRC go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
#+END_SRC

The expression

#+BEGIN_SRC go
T.Mv
#+END_SRC

yields a function equivalent to Mv but with an explicit receiver as its first
argument; it has signature

#+BEGIN_SRC go
func(tv T, a int) int
#+END_SRC

That function may be called normally with an explicit receiver, so these five
invocations are equivalent:

#+BEGIN_SRC go
t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
#+END_SRC

Similarly, the expression

#+BEGIN_SRC go
(*T).Mp
#+END_SRC

yields a function value representing Mp with signature

#+BEGIN_SRC go
func(tp *T, f float32) float32
#+END_SRC

For a method with a value receiver, one can derive a function with an explicit
pointer receiver, so

#+BEGIN_SRC go
(*T).Mv
#+END_SRC

yields a function value representing Mv with signature

#+BEGIN_SRC go
func(tv *T, a int) int
#+END_SRC

Such a function indirects through the receiver to create a value to pass as the
receiver to the underlying method; the method does not overwrite the value whose
address is passed in the function call.

The final case, a value-receiver function for a pointer-receiver method, is
illegal because pointer-receiver methods are not in the method set of the value
type.

Function values derived from methods are called with function call syntax; the
receiver is provided as the first argument to the call. That is, given f :=
T.Mv, f is invoked as f(t, 7) not t.f(7). To construct a function that binds the
receiver, use a function literal or method value.

It is legal to derive a function value from a method of an interface type. The
resulting function takes an explicit receiver of that interface type.

** Method values

If the expression x has static type T and M is in the method set of type T, x.M
is called a method value. The method value x.M is a function value that is
callable with the same arguments as a method call of x.M. The expression x is
evaluated and saved during the evaluation of the method value; the saved copy is
then used as the receiver in any calls, which may be executed later.

The type T may be an interface or non-interface type.

As in the discussion of method expressions above, consider a struct type T with
two methods, Mv, whose receiver is of type T, and Mp, whose receiver is of type
*T.

#+BEGIN_SRC go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
var pt *T
func makeT() T
#+END_SRC

The expression

#+BEGIN_SRC go
t.Mv
#+END_SRC

yields a function value of type

#+BEGIN_SRC go
func(int) int
#+END_SRC

These two invocations are equivalent:

#+BEGIN_SRC go
t.Mv(7)
f := t.Mv; f(7)
#+END_SRC

Similarly, the expression

#+BEGIN_SRC go
pt.Mp
#+END_SRC

yields a function value of type

#+BEGIN_SRC go
func(float32) float32
#+END_SRC

As with selectors, a reference to a non-interface method with a value receiver
using a pointer will automatically dereference that pointer: pt.Mv is equivalent
to (*pt).Mv.

As with method calls, a reference to a non-interface method with a pointer
receiver using an addressable value will automatically take the address of that
value: t.Mp is equivalent to (&t).Mp.

#+BEGIN_SRC go
f := t.Mv; f(7)   // like t.Mv(7)
f := pt.Mp; f(7)  // like pt.Mp(7)
f := pt.Mv; f(7)  // like (*pt).Mv(7)
f := t.Mp; f(7)   // like (&t).Mp(7)
f := makeT().Mp   // invalid: result of makeT() is not addressable
#+END_SRC

Although the examples above use non-interface types, it is also legal to create
a method value from a value of interface type.

#+BEGIN_SRC go
var i interface { M(int) } = myVal
f := i.M; f(7)  // like i.M(7)
#+END_SRC

** Index expressions

A primary expression of the form

#+BEGIN_SRC go
a[x]
#+END_SRC

denotes the element of the array, pointer to array, slice, string or map a
indexed by x. The value x is called the index or map key, respectively. The
following rules apply:

If a is not a map:

    1) the index x must be of integer type or untyped; it is in range if 0 <= x
       < len(a), otherwise it is out of range
    2) a constant index must be non-negative and representable by a value of
       type int

For a of array type A:

    1) a constant index must be in range
    2) if x is out of range at run time, a run-time panic occurs
    3) a[x] is the array element at index x and the type of a[x] is the element
       type of A

For a of pointer to array type:

    1) a[x] is shorthand for (*a)[x]

For a of slice type S:

    1) if x is out of range at run time, a run-time panic occurs
    2) a[x] is the slice element at index x and the type of a[x] is the element
       type of S

For a of string type:

    1) a constant index must be in range if the string a is also constant
    2) if x is out of range at run time, a run-time panic occurs
    3) a[x] is the non-constant byte value at index x and the type of a[x] is
       byte
    4) a[x] may not be assigned to

For a of map type M:

    1) x's type must be assignable to the key type of M
    2) if the map contains an entry with key x, a[x] is the map value with key x
       and the type of a[x] is the value type of M
    3) if the map is nil or does not contain such an entry, a[x] is the zero
       value for the value type of M

Otherwise a[x] is illegal.

An index expression on a map a of type map[K]V used in an assignment or
initialization of the special form

#+BEGIN_SRC go
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
var v, ok T = a[x]
#+END_SRC

yields an additional untyped boolean value. The value of ok is true if the key x
is present in the map, and false otherwise.

Assigning to an element of a nil map causes a run-time panic.

** Slice expressions

Slice expressions construct a substring or slice from a string, array, pointer
to array, or slice. There are two variants: a simple form that specifies a low
and high bound, and a full form that also specifies a bound on the capacity.

*** Simple slice expressions

For a string, array, pointer to array, or slice a, the primary expression

#+BEGIN_SRC go
a[low : high]
#+END_SRC

constructs a substring or slice. The indices low and high select which elements
of operand a appear in the result. The result has indices starting at 0 and
length equal to high - low. After slicing the array a

#+BEGIN_SRC go
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
#+END_SRC

the slice s has type []int, length 3, capacity 4, and elements

#+BEGIN_SRC go
s[0] == 2
s[1] == 3
s[2] == 4
#+END_SRC

For convenience, any of the indices may be omitted. A missing low index defaults
to zero; a missing high index defaults to the length of the sliced operand:

#+BEGIN_SRC go
a[2:]  // same as a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]
#+END_SRC

If a is a pointer to an array, a[low : high] is shorthand for (*a)[low : high].

For arrays or strings, the indices are in range if 0 <= low <= high <= len(a),
otherwise they are out of range. For slices, the upper index bound is the slice
capacity cap(a) rather than the length. A constant index must be non-negative
and representable by a value of type int; for arrays or constant strings,
constant indices must also be in range. If both indices are constant, they must
satisfy low <= high. If the indices are out of range at run time, a run-time
panic occurs.

Except for untyped strings, if the sliced operand is a string or slice, the
result of the slice operation is a non-constant value of the same type as the
operand. For untyped string operands the result is a non-constant value of type
string. If the sliced operand is an array, it must be addressable and the result
of the slice operation is a slice with the same element type as the array.

If the sliced operand of a valid slice expression is a nil slice, the result is
a nil slice. Otherwise, the result shares its underlying array with the operand.

*** Full slice expressions

For an array, pointer to array, or slice a (but not a string), the primary
expression

#+BEGIN_SRC go
a[low : high : max]
#+END_SRC

constructs a slice of the same type, and with the same length and elements as
the simple slice expression a[low : high]. Additionally, it controls the
resulting slice's capacity by setting it to max - low. Only the first index may
be omitted; it defaults to 0. After slicing the array a

#+BEGIN_SRC go
a := [5]int{1, 2, 3, 4, 5}
t := a[1:3:5]
#+END_SRC

the slice t has type []int, length 2, capacity 4, and elements

#+BEGIN_SRC go
t[0] == 2
t[1] == 3
#+END_SRC

As for simple slice expressions, if a is a pointer to an array, a[low : high :
max] is shorthand for (*a)[low : high : max]. If the sliced operand is an array,
it must be addressable.

The indices are in range if 0 <= low <= high <= max <= cap(a), otherwise they
are out of range. A constant index must be non-negative and representable by a
value of type int; for arrays, constant indices must also be in range. If
multiple indices are constant, the constants that are present must be in range
relative to each other. If the indices are out of range at run time, a run-time
panic occurs.

** Type assertions

For an expression x of interface type and a type T, the primary expression

#+BEGIN_SRC go
x.(T)
#+END_SRC

asserts that x is not nil and that the value stored in x is of type T. The
notation x.(T) is called a type assertion.

More precisely, if T is not an interface type, x.(T) asserts that the dynamic
type of x is identical to the type T. In this case, T must implement the
(interface) type of x; otherwise the type assertion is invalid since it is not
possible for x to store a value of type T. If T is an interface type, x.(T)
asserts that the dynamic type of x implements the interface T.

If the type assertion holds, the value of the expression is the value stored in
x and its type is T. If the type assertion is false, a run-time panic occurs. In
other words, even though the dynamic type of x is known only at run time, the
type of x.(T) is known to be T in a correct program.

#+BEGIN_SRC go
var x interface{} = 7          // x has dynamic type int and value 7
i := x.(int)                   // i has type int and value 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // illegal: string does not implement I (missing method m)
	r := y.(io.Reader)     // r has type io.Reader and the dynamic type of y must implement both I and io.Reader
	…
}
#+END_SRC

A type assertion used in an assignment or initialization of the special form

#+BEGIN_SRC go
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
var v, ok T1 = x.(T)
#+END_SRC

yields an additional untyped boolean value. The value of ok is true if the
assertion holds. Otherwise it is false and the value of v is the zero value for
type T. No run-time panic occurs in this case.

** Calls

Given an expression f of function type F,

#+BEGIN_SRC go
f(a1, a2, … an)
#+END_SRC

calls f with arguments a1, a2, … an. Except for one special case, arguments
must be single-valued expressions assignable to the parameter types of F and are
evaluated before the function is called. The type of the expression is the
result type of F. A method invocation is similar but the method itself is
specified as a selector upon a value of the receiver type for the method.

#+BEGIN_SRC go
math.Atan2(x, y)  // function call
var pt *Point
pt.Scale(3.5)     // method call with receiver pt
#+END_SRC

In a function call, the function value and arguments are evaluated in the usual
order. After they are evaluated, the parameters of the call are passed by value
to the function and the called function begins execution. The return parameters
of the function are passed by value back to the calling function when the
function returns.

Calling a nil function value causes a run-time panic.

As a special case, if the return values of a function or method g are equal in
number and individually assignable to the parameters of another function or
method f, then the call f(g(parameters_of_g)) will invoke f after binding the
return values of g to the parameters of f in order. The call of f must contain
no parameters other than the call of g, and g must have at least one return
value. If f has a final ... parameter, it is assigned the return values of g
that remain after assignment of regular parameters.

#+BEGIN_SRC go
func Split(s string, pos int) (string, string) {
	return s[0:pos], s[pos:]
}

func Join(s, t string) string {
	return s + t
}

if Join(Split(value, len(value)/2)) != value {
	log.Panic("test fails")
}
#+END_SRC

A method call x.m() is valid if the method set of (the type of) x contains m and
the argument list can be assigned to the parameter list of m. If x is
addressable and &x's method set contains m, x.m() is shorthand for (&x).m():

#+BEGIN_SRC go
var p Point
p.Scale(3.5)
#+END_SRC

There is no distinct method type and there are no method literals.

** Passing arguments to ... parameters

If f is variadic with a final parameter p of type ...T, then within f the type
of p is equivalent to type []T. If f is invoked with no actual arguments for p,
the value passed to p is nil. Otherwise, the value passed is a new slice of type
[]T with a new underlying array whose successive elements are the actual
arguments, which all must be assignable to T. The length and capacity of the
slice is therefore the number of arguments bound to p and may differ for each
call site.

Given the function and calls

#+BEGIN_SRC go
func Greeting(prefix string, who ...string)
Greeting("nobody")
Greeting("hello:", "Joe", "Anna", "Eileen")
#+END_SRC

within Greeting, who will have the value nil in the first call, and
[]string{"Joe", "Anna", "Eileen"} in the second.

If the final argument is assignable to a slice type []T, it may be passed
unchanged as the value for a ...T parameter if the argument is followed by ....
In this case no new slice is created.

Given the slice s and call

#+BEGIN_SRC go
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
#+END_SRC

within Greeting, who will have the same value as s with the same underlying
array.

** Operators

Operators combine operands into expressions.

#+BEGIN_SRC text
Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
#+END_SRC

Comparisons are discussed elsewhere. For other binary operators, the operand
types must be identical unless the operation involves shifts or untyped
constants. For operations involving constants only, see the section on constant
expressions.

Except for shift operations, if one operand is an untyped constant and the other
operand is not, the constant is converted to the type of the other operand.

The right operand in a shift expression must have unsigned integer type or be an
untyped constant representable by a value of type uint. If the left operand of a
non-constant shift expression is an untyped constant, it is first converted to
the type it would assume if the shift expression were replaced by its left
operand alone.

#+BEGIN_SRC go
var s uint = 33
var i = 1<<s           // 1 has type int
var j int32 = 1<<s     // 1 has type int32; j == 0
var k = uint64(1<<s)   // 1 has type uint64; k == 1<<33
var m int = 1.0<<s     // 1.0 has type int; m == 0 if ints are 32bits in size
var n = 1.0<<s == j    // 1.0 has type int32; n == true
var o = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size
var p = 1<<s == 1<<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int
var u = 1.0<<s         // illegal: 1.0 has type float64, cannot shift
var u1 = 1.0<<s != 0   // illegal: 1.0 has type float64, cannot shift
var u2 = 1<<s != 1.0   // illegal: 1 has type float64, cannot shift
var v float32 = 1<<s   // illegal: 1 has type float32, cannot shift
var w int64 = 1.0<<33  // 1.0<<33 is a constant shift expression
#+END_SRC

*** Operator precedence

Unary operators have the highest precedence. As the ++ and -- operators form
statements, not expressions, they fall outside the operator hierarchy. As a
consequence, statement *p++ is the same as (*p)++.

There are five precedence levels for binary operators. Multiplication operators
bind strongest, followed by addition operators, comparison operators, &&
(logical AND), and finally || (logical OR):

#+BEGIN_SRC text
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
#+END_SRC

Binary operators of the same precedence associate from left to right. For
instance, x / y * z is the same as (x / y) * z.

#+BEGIN_SRC go
+x
23 + 3*x[i]
x <= f()
^a >> b
f() || g()
x == y+1 && <-chanPtr > 0
#+END_SRC

** Arithmetic operators

Arithmetic operators apply to numeric values and yield a result of the same type
as the first operand. The four standard arithmetic operators (+, -, *, /) apply
to integer, floating-point, and complex types; + also applies to strings. The
bitwise logical and shift operators apply to integers only.

#+BEGIN_SRC text
 +    sum                    integers, floats, complex values, strings
 -    difference             integers, floats, complex values
 *    product                integers, floats, complex values
 /    quotient               integers, floats, complex values
 %    remainder              integers

 &    bitwise AND            integers
 |    bitwise OR             integers
 ^    bitwise XOR            integers
 &^   bit clear (AND NOT)    integers

 <<   left shift             integer << unsigned integer
 >>   right shift            integer >> unsigned integer
#+END_SRC

*** Integer operators

For two integer values x and y, the integer quotient q = x / y and remainder r =
x % y satisfy the following relationships:

#+BEGIN_SRC text
x = q*y + r  and  |r| < |y|
#+END_SRC

with x / y truncated towards zero ("truncated division").

#+BEGIN_SRC text
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
#+END_SRC

As an exception to this rule, if the dividend x is the most negative value for
the int type of x, the quotient q = x / -1 is equal to x (and r = 0).

#+BEGIN_SRC text
			 x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
#+END_SRC

If the divisor is a constant, it must not be zero. If the divisor is zero at run
time, a run-time panic occurs. If the dividend is non-negative and the divisor
is a constant power of 2, the division may be replaced by a right shift, and
computing the remainder may be replaced by a bitwise AND operation:

#+BEGIN_SRC text
 x     x / 4     x % 4     x >> 2     x & 3
 11      2         3         2          3
-11     -2        -3        -3          1
#+END_SRC

The shift operators shift the left operand by the shift count specified by the
right operand. They implement arithmetic shifts if the left operand is a signed
integer and logical shifts if it is an unsigned integer. There is no upper limit
on the shift count. Shifts behave as if the left operand is shifted n times by 1
for a shift count of n. As a result, x << 1 is the same as x*2 and x >> 1 is the
same as x/2 but truncated towards negative infinity.

For integer operands, the unary operators +, -, and ^ are defined as follows:

#+BEGIN_SRC text
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
#+END_SRC

*** Integer overflow

For unsigned integer values, the operations +, -, *, and << are computed modulo
2n, where n is the bit width of the unsigned integer's type. Loosely speaking,
these unsigned integer operations discard high bits upon overflow, and programs
may rely on ``wrap around''.

For signed integers, the operations +, -, *, and << may legally overflow and the
resulting value exists and is deterministically defined by the signed integer
representation, the operation, and its operands. No exception is raised as a
result of overflow. A compiler may not optimize code under the assumption that
overflow does not occur. For instance, it may not assume that x < x + 1 is
always true.

*** Floating-point operators

For floating-point and complex numbers, +x is the same as x, while -x is the
negation of x. The result of a floating-point or complex division by zero is not
specified beyond the IEEE-754 standard; whether a run-time panic occurs is
implementation-specific.

An implementation may combine multiple floating-point operations into a single
fused operation, possibly across statements, and produce a result that differs
from the value obtained by executing and rounding the instructions individually.
A floating-point type conversion explicitly rounds to the precision of the
target type, preventing fusion that would discard that rounding.

For instance, some architectures provide a "fused multiply and add" (FMA)
instruction that computes x*y + z without rounding the intermediate result x*y.
These examples show when a Go implementation can use that instruction:

#+BEGIN_SRC go
// FMA allowed for computing r, because x*y is not explicitly rounded:
r  = x*y + z
r  = z;   r += x*y
t  = x*y; r = t + z
*p = x*y; r = *p + z
r  = x*y + float64(z)

// FMA disallowed for computing r, because it would omit rounding of x*y:
r  = float64(x*y) + z
r  = z; r += float64(x*y)
t  = float64(x*y); r = t + z
#+END_SRC

*** String concatenation

Strings can be concatenated using the + operator or the += assignment operator:

#+BEGIN_SRC go
s := "hi" + string(c)
s += " and good bye"
#+END_SRC

String addition creates a new string by concatenating the operands.

** Comparison operators

Comparison operators compare two operands and yield an untyped boolean value.

#+BEGIN_SRC text
==    equal
!=    not equal
<     less
<=    less or equal
>     greater
>=    greater or equal
#+END_SRC

In any comparison, the first operand must be assignable to the type of the
second operand, or vice versa.

The equality operators == and != apply to operands that are comparable. The
ordering operators <, <=, >, and >= apply to operands that are ordered. These
terms and the result of the comparisons are defined as follows:

    1) Boolean values are comparable. Two boolean values are equal if they are
       either both true or both false.
    2) Integer values are comparable and ordered, in the usual way.
    3) Floating-point values are comparable and ordered, as defined by the
       IEEE-754 standard.
    4) Complex values are comparable. Two complex values u and v are equal if
       both real(u) == real(v) and imag(u) == imag(v).
    5) String values are comparable and ordered, lexically byte-wise.
    6) Pointer values are comparable. Two pointer values are equal if they point
       to the same variable or if both have value nil. Pointers to distinct
       zero-size variables may or may not be equal.
    7) Channel values are comparable. Two channel values are equal if they were
       created by the same call to make or if both have value nil.
    8) Interface values are comparable. Two interface values are equal if they
       have identical dynamic types and equal dynamic values or if both have
       value nil.
    9) A value x of non-interface type X and a value t of interface type T are
       comparable when values of type X are comparable and X implements T. They
       are equal if t's dynamic type is identical to X and t's dynamic value is
       equal to x.
   10) Struct values are comparable if all their fields are comparable. Two
       struct values are equal if their corresponding non-blank fields are
       equal.
   11) Array values are comparable if values of the array element type are
       comparable. Two array values are equal if their corresponding elements
       are equal.
   12) A comparison of two interface values with identical dynamic types causes
       a run-time panic if values of that type are not comparable. This behavior
       applies not only to direct interface value comparisons but also when
       comparing arrays of interface values or structs with interface-valued
       fields.

Slice, map, and function values are not comparable. However, as a special case,
a slice, map, or function value may be compared to the predeclared identifier
nil. Comparison of pointer, channel, and interface values to nil is also allowed
and follows from the general rules above.

#+BEGIN_SRC go
const c = 3 < 4            // c is the untyped boolean constant true

type MyBool bool
var x, y int
var (
	// The result of a comparison is an untyped boolean.
	// The usual assignment rules apply.
	b3        = x == y // b3 has type bool
	b4 bool   = x == y // b4 has type bool
	b5 MyBool = x == y // b5 has type MyBool
)
#+END_SRC

** Logical operators

Logical operators apply to boolean values and yield a result of the same type as
the operands. The right operand is evaluated conditionally.

#+BEGIN_SRC text
&&    conditional AND    p && q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
#+END_SRC

** Address operators

For an operand x of type T, the address operation &x generates a pointer of type
*T to x. The operand must be addressable, that is, either a variable, pointer
indirection, or slice indexing operation; or a field selector of an addressable
struct operand; or an array indexing operation of an addressable array. As an
exception to the addressability requirement, x may also be a (possibly
parenthesized) composite literal. If the evaluation of x would cause a run-time
panic, then the evaluation of &x does too.

For an operand x of pointer type *T, the pointer indirection *x denotes the
variable of type T pointed to by x. If x is nil, an attempt to evaluate *x will
cause a run-time panic.

#+BEGIN_SRC go
&x
&a[f(2)]
&Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // causes a run-time panic
&*x  // causes a run-time panic
#+END_SRC

** Receive operator

For an operand ch of channel type, the value of the receive operation <-ch is
the value received from the channel ch. The channel direction must permit
receive operations, and the type of the receive operation is the element type of
the channel. The expression blocks until a value is available. Receiving from a
nil channel blocks forever. A receive operation on a closed channel can always
proceed immediately, yielding the element type's zero value after any previously
sent values have been received.

#+BEGIN_SRC go
v1 := <-ch
v2 = <-ch
f(<-ch)
<-strobe  // wait until clock pulse and discard received value
#+END_SRC

A receive expression used in an assignment or initialization of the special form

#+BEGIN_SRC go
x, ok = <-ch
x, ok := <-ch
var x, ok = <-ch
var x, ok T = <-ch
#+END_SRC

yields an additional untyped boolean result reporting whether the communication
succeeded. The value of ok is true if the value received was delivered by a
successful send operation to the channel, or false if it is a zero value
generated because the channel is closed and empty.

** Conversions

Conversions are expressions of the form T(x) where T is a type and x is an
expression that can be converted to type T.

#+BEGIN_SRC text
Conversion = Type "(" Expression [ "," ] ")" .
#+END_SRC

If the type starts with the operator * or <-, or if the type starts with the
keyword func and has no result list, it must be parenthesized when necessary to
avoid ambiguity:

#+BEGIN_SRC go
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to *Point
<-chan int(c)    // same as <-(chan int(c))
(<-chan int)(c)  // c is converted to <-chan int
func()(x)        // function signature func() x
(func())(x)      // x is converted to func()
(func() int)(x)  // x is converted to func() int
func() int(x)    // x is converted to func() int (unambiguous)
#+END_SRC

A constant value x can be converted to type T in any of these cases:

    1) x is representable by a value of type T.
    2) x is a floating-point constant, T is a floating-point type, and x is
       representable by a value of type T after rounding using IEEE 754
       round-to-even rules, but with an IEEE -0.0 further rounded to an unsigned
       0.0. The constant T(x) is the rounded value.
    3) x is an integer constant and T is a string type. The same rule as for
       non-constant x applies in this case.

Converting a constant yields a typed constant as result.

#+BEGIN_SRC go
uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
float32(0.49999999)      // 0.5 of type float32
float64(-1e-1000)        // 0.0 of type float64
string('x')              // "x" of type string
string(0x266c)           // "♬" of type string
MyString("foo" + "bar")  // "foobar" of type MyString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type
int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant
#+END_SRC

A non-constant value x can be converted to type T in any of these cases:

    1) x is assignable to T.
    2) ignoring struct tags (see below), x's type and T have identical
       underlying types.
    3) ignoring struct tags (see below), x's type and T are pointer types that
       are not defined types, and their pointer base types have identical
       underlying types.
    4) x's type and T are both integer or floating point types.
    5) x's type and T are both complex types.
    6) x is an integer or a slice of bytes or runes and T is a string type.
    7) x is a string and T is a slice of bytes or runes.

Struct tags are ignored when comparing struct types for identity for the purpose
of conversion:

#+BEGIN_SRC go
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}

var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}

var person = (*Person)(data)  // ignoring tags, the underlying types are identical
#+END_SRC

Specific rules apply to (non-constant) conversions between numeric types or to
and from a string type. These conversions may change the representation of x and
incur a run-time cost. All other conversions only change the type but not the
representation of x.

There is no linguistic mechanism to convert between pointers and integers. The
package unsafe implements this functionality under restricted circumstances.

*** Conversions between numeric types

For the conversion of non-constant numeric values, the following rules apply:

When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size. For example, if v := uint16(0x10F0), then uint32(int8(v)) == 0xFFFFFFF0. The conversion always yields a valid value; there is no indication of overflow.
When converting a floating-point number to an integer, the fraction is discarded (truncation towards zero).
When converting an integer or floating-point number to a floating-point type, or a complex number to another complex type, the result value is rounded to the precision specified by the destination type. For instance, the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x's value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not.
In all non-constant conversions involving floating-point or complex values, if the result type cannot represent the value the conversion succeeds but the result value is implementation-dependent.

*** Conversions to and from a string type

Converting a signed or unsigned integer value to a string type yields a string
containing the UTF-8 representation of the integer. Values outside the range of
valid Unicode code points are converted to "\uFFFD".

#+BEGIN_SRC go
string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd"
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"
#+END_SRC

Converting a slice of bytes to a string type yields a string whose successive
bytes are the elements of the slice.

#+BEGIN_SRC go
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"
string([]byte{})                                     // ""
string([]byte(nil))                                  // ""

type MyBytes []byte
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"
#+END_SRC

Converting a slice of runes to a string type yields a string that is the
concatenation of the individual rune values converted to strings.

#+BEGIN_SRC go
string([]rune{0x767d, 0x9d6c, 0x7fd4})   // "\u767d\u9d6c\u7fd4" == "白鵬翔"
string([]rune{})                         // ""
string([]rune(nil))                      // ""

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
#+END_SRC

Converting a value of a string type to a slice of bytes type yields a slice
whose successive elements are the bytes of the string.

#+BEGIN_SRC go
[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
[]byte("")        // []byte{}

MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
#+END_SRC

Converting a value of a string type to a slice of runes type yields a slice
containing the individual Unicode code points of the string.

#+BEGIN_SRC go
[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
[]rune("")                 // []rune{}

MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}
#+END_SRC

** Constant expressions

Constant expressions may contain only constant operands and are evaluated at
compile time.

Untyped boolean, numeric, and string constants may be used as operands wherever
it is legal to use an operand of boolean, numeric, or string type, respectively.
Except for shift operations, if the operands of a binary operation are different
kinds of untyped constants, the operation and, for non-boolean operations, the
result use the kind that appears later in this list: integer, rune,
floating-point, complex. For example, an untyped integer constant divided by an
untyped complex constant yields an untyped complex constant.

A constant comparison always yields an untyped boolean constant. If the left
operand of a constant shift expression is an untyped constant, the result is an
integer constant; otherwise it is a constant of the same type as the left
operand, which must be of integer type. Applying all other operators to untyped
constants results in an untyped constant of the same kind (that is, a boolean,
integer, floating-point, complex, or string constant).

#+BEGIN_SRC go
const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
const b = 15 / 4           // b == 3     (untyped integer constant)
const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)
const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)
const d = 1 << 3.0         // d == 8     (untyped integer constant)
const e = 1.0 << 3         // e == 8     (untyped integer constant)
const f = int32(1) << 33   // illegal    (constant 8589934592 overflows int32)
const g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" > "bar"    // h == true  (untyped boolean constant)
const j = true             // j == true  (untyped boolean constant)
const k = 'w' + 1          // k == 'x'   (untyped rune constant)
const l = "hi"             // l == "hi"  (untyped string constant)
const m = string(k)        // m == "x"   (type string)
const Σ = 1 - 0.707i       //            (untyped complex constant)
const Δ = Σ + 2.0e-4       //            (untyped complex constant)
const Φ = iota*1i - 1/1i   //            (untyped complex constant)
#+END_SRC

Applying the built-in function complex to untyped integer, rune, or
floating-point constants yields an untyped complex constant.

#+BEGIN_SRC go
const ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)
const iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)
#+END_SRC

Constant expressions are always evaluated exactly; intermediate values and the
constants themselves may require precision significantly larger than supported
by any predeclared type in the language. The following are legal declarations:

#+BEGIN_SRC go
const Huge = 1 << 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)
const Four int8 = Huge >> 98  // Four == 4                                (type int8)
#+END_SRC

The divisor of a constant division or remainder operation must not be zero:

#+BEGIN_SRC go
3.14 / 0.0   // illegal: division by zero
#+END_SRC

The values of typed constants must always be accurately representable as values
of the constant type. The following constant expressions are illegal:

#+BEGIN_SRC go
uint(-1)     // -1 cannot be represented as a uint
int(3.14)    // 3.14 cannot be represented as an int
int64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64
Four * 300   // operand 300 cannot be represented as an int8 (type of Four)
Four * 100   // product 400 cannot be represented as an int8 (type of Four)
#+END_SRC

The mask used by the unary bitwise complement operator ^ matches the rule for
non-constants: the mask is all 1s for unsigned constants and -1 for signed and
untyped constants.

#+BEGIN_SRC go
^1         // untyped integer constant, equal to -2
uint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8
^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // same as int8(-2)
^int8(1)   // same as -1 ^ int8(1) = -2
#+END_SRC

Implementation restriction: A compiler may use rounding while computing untyped
floating-point or complex constant expressions; see the implementation
restriction in the section on constants. This rounding may cause a
floating-point constant expression to be invalid in an integer context, even if
it would be integral when calculated using infinite precision, and vice versa.

** Order of evaluation

At package level, initialization dependencies determine the evaluation order of
individual initialization expressions in variable declarations. Otherwise, when
evaluating the operands of an expression, assignment, or return statement, all
function calls, method calls, and communication operations are evaluated in
lexical left-to-right order.

For example, in the (function-local) assignment

#+BEGIN_SRC go
y[f()], ok = g(h(), i()+x[j()], <-c), k()
#+END_SRC

the function calls and communication happen in the order f(), h(), i(), j(),
<-c, g(), and k(). However, the order of those events compared to the evaluation
and indexing of x and the evaluation of y is not specified.

#+BEGIN_SRC go
a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified
m := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified
n := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified
#+END_SRC

At package level, initialization dependencies override the left-to-right rule
for individual initialization expressions, but not for operands within each
expression:

#+BEGIN_SRC go
var a, b, c = f() + v(), g(), sqr(u()) + v()

func f() int        { return c }
func g() int        { return a }
func sqr(x int) int { return x*x }

// functions u and v are independent of all other variables and functions
#END_SRC

The function calls happen in the order u(), sqr(), v(), f(), v(), and g().

Floating-point operations within a single expression are evaluated according to
the associativity of the operators. Explicit parentheses affect the evaluation
by overriding the default associativity. In the expression x + (y + z) the
addition y + z is performed before adding x.
