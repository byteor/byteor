# go channel

- close/send/recv

+-----------+-------------+----------------+----------------------------+
| Operation | nil channel | closed channel | not-closed non-nil channel |
+-----------+-------------+----------------+----------------------------+
|      close|        panic|           panic|            succeed to close|
|-----------+-------------+----------------+----------------------------|
|    send to|   block ever|           panic|    block or succeed to send|
|-----------+-------------+----------------+----------------------------|
|  recv from|   block ever|     never block|    block or succeed to recv|
+-----------+-------------+----------------+----------------------------+

- channel vs mutex

* Use locking (mutexes) when:
  * caching information in a shared data structure
  * holding state information, that is context or status of the running application

* Use channels when:
  * communicating asynchronous results
  * distributing units of work
  * passing ownership of data

* Wait Group

Another important synchronisation primitive is sync.WaitGroup. These allow
co-operating goroutines to collectively wait for a threshold event before
proceeding independently again. This is useful typically in two cases.

Firstly, when 'cleaning up', a sync.WaitGroup can be used to ensure that all
goroutines - including the main one - wait before all terminating cleanly.

The second more general case is of a cyclic algorithm that involves a set of
goroutines that all work independently for a while, then all wait on a barrier,
before proceeding independently again. This pattern might be repeated many
times. Data might be exchanged at the barrier event. This strategy is the basis
of Bulk Synchronous Parallelism (BSP).

Channel communication, mutexes and wait-groups are complementary and can be
combined.
