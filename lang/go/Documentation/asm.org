#+TITLE: A Quick Guide to Go's Assembler
#+AUTHOR: https://golang.org/doc/asm

* Symbols

There are four predeclared symbols that refer to pseudo-registers. These are not
real registers, but rather virtual registers maintained by the tool chain, such
as a frame pointer. The set of pseudo-registers is the same for all
architectures:

- FP: Frame pointer: arguments and locals.
- PC: Program counter: jumps and branches.
- SB: Static base pointer: global symbols.
- SP: Stack pointer: top of stack.

All user-defined symbols are written as offsets to the pseudo-registers FP
(arguments and locals) and SB (globals).

The SB pseudo-register can be thought of as the origin of memory, so the symbol
foo(SB) is the name foo as an address in memory. This form is used to name
global functions and data. Adding <> to the name, as in foo<>(SB), makes the
name visible only in the current source file, like a top-level static
declaration in a C file. Adding an offset to the name refers to that offset from
the symbol's address, so foo+4(SB) is four bytes past the start of foo.

The FP pseudo-register is a virtual frame pointer used to refer to function
arguments. The compilers maintain a virtual frame pointer and refer to the
arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the
first argument to the function, 8(FP) is the second (on a 64-bit machine), and
so on. However, when referring to a function argument this way, it is necessary
to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP).
(The meaning of the offset—offset from the frame pointer—distinct from its use
with SB, where it is an offset from the symbol.) The assembler enforces this
convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically
irrelevant but should be used to document the argument's name. It is worth
stressing that FP is always a pseudo-register, not a hardware register, even on
architectures with a hardware frame pointer.

For assembly functions with Go prototypes, go vet will check that the argument
names and offsets match. On 32-bit systems, the low and high 32 bits of a 64-bit
value are distinguished by adding a _lo or _hi suffix to the name, as in
arg_lo+0(FP) or arg_hi+4(FP). If a Go prototype does not name its result, the
expected assembly name is ret.

The SP pseudo-register is a virtual stack pointer used to refer to frame-local
variables and the arguments being prepared for function calls. It points to the
top of the local stack frame, so references should use negative offsets in the
range [−framesize, 0): x-8(SP), y-4(SP), and so on.

On architectures with a hardware register named SP, the name prefix
distinguishes references to the virtual stack pointer from references to the
architectural SP register. That is, x-8(SP) and -8(SP) are different memory
locations: the first refers to the virtual stack pointer pseudo-register, while
the second refers to the hardware's SP register.

On machines where SP and PC are traditionally aliases for a physical, numbered
register, in the Go assembler the names SP and PC are still treated specially;
for instance, references to SP require a symbol, much like FP. To access the
actual hardware register use the true R name. For example, on the ARM
architecture the hardware SP and PC are accessible as R13 and R15.

Branches and direct jumps are always written as offsets to the PC, or as jumps
to labels:

#+BEGIN_SRC asm
label:
	MOVW $0, R1
	JMP label
#+END_SRC

Each label is visible only within the function in which it is defined. It is
therefore permitted for multiple functions in a file to define and use the same
label names. Direct jumps and call instructions can target text symbols, such as
name(SB), but not offsets from symbols, such as name+4(SB).

Instructions, registers, and assembler directives are always in UPPER CASE to
remind you that assembly programming is a fraught endeavor. (Exception: the g
register renaming on ARM.)

In Go object files and binaries, the full name of a symbol is the package path
followed by a period and the symbol name: fmt.Printf or math/rand.Int. Because
the assembler's parser treats period and slash as punctuation, those strings
cannot be used directly as identifier names. Instead, the assembler allows the
middle dot character U+00B7 and the division slash U+2215 in identifiers and
rewrites them to plain period and slash. Within an assembler source file, the
symbols above are written as fmt·Printf and math∕rand·Int. The assembly listings
generated by the compilers when using the -S flag show the period and slash
directly instead of the Unicode replacements required by the assemblers.

Most hand-written assembly files do not include the full package path in symbol
names, because the linker inserts the package path of the current object file at
the beginning of any name starting with a period: in an assembly source file
within the math/rand package implementation, the package's Int function can be
referred to as ·Int. This convention avoids the need to hard-code a package's
import path in its own source code, making it easier to move the code from one
location to another.

* Directives

The assembler uses various directives to bind text and data to symbol names. For
example, here is a simple complete function definition. The TEXT directive
declares the symbol runtime·profileloop and the instructions that follow form
the body of the function. The last instruction in a TEXT block must be some sort
of jump, usually a RET (pseudo-)instruction. (If it's not, the linker will
append a jump-to-itself instruction; there is no fallthrough in TEXTs.) After
the symbol, the arguments are flags (see below) and the frame size, a constant
(but see below):

#+BEGIN_SRC asm
TEXT runtime·profileloop(SB),NOSPLIT,$8
	MOVQ $runtime·profileloop1(SB), CX
	MOVQ CX, 0(SP)
	CALL runtime·externalthreadhandler(SB)
	RET
#+END_SRC

In the general case, the frame size is followed by an argument size, separated
by a minus sign. (It's not a subtraction, just idiosyncratic syntax.) The frame
size $24-8 states that the function has a 24-byte frame and is called with 8
bytes of argument, which live on the caller's frame. If NOSPLIT is not specified
for the TEXT, the argument size must be provided. For assembly functions with Go
prototypes, go vet will check that the argument size is correct.

Note that the symbol name uses a middle dot to separate the components and is
specified as an offset from the static base pseudo-register SB. This function
would be called from Go source for package runtime using the simple name
profileloop.

Global data symbols are defined by a sequence of initializing DATA directives
followed by a GLOBL directive. Each DATA directive initializes a section of the
corresponding memory. The memory not explicitly initialized is zeroed. The
general form of the DATA directive is

#+BEGIN_SRC asm
DATA symbol+offset(SB)/width, value
#+END_SRC

which initializes the symbol memory at the given offset and width with the given
value. The DATA directives for a given symbol must be written with increasing
offsets.

The GLOBL directive declares a symbol to be global. The arguments are optional
flags and the size of the data being declared as a global, which will have
initial value all zeros unless a DATA directive has initialized it. The GLOBL
directive must follow any corresponding DATA directives.

For example,

#+BEGIN_SRC asm
DATA divtab<>+0x00(SB)/4, $0xf4f8fcff
DATA divtab<>+0x04(SB)/4, $0xe6eaedf0
...
DATA divtab<>+0x3c(SB)/4, $0x81828384
GLOBL divtab<>(SB), RODATA, $64
GLOBL runtime·tlsoffset(SB), NOPTR, $4
#+END_SRC

declares and initializes divtab<>, a read-only 64-byte table of 4-byte integer
values, and declares runtime·tlsoffset, a 4-byte, implicitly zeroed variable
that contains no pointers.

There may be one or two arguments to the directives. If there are two, the first
is a bit mask of flags, which can be written as numeric expressions, added or
or-ed together, or can be set symbolically for easier absorption by a human.
Their values, defined in the standard #include file textflag.h, are:

- NOPROF = 1
(For TEXT items.) Don't profile the marked function. This flag is deprecated.

- DUPOK = 2
It is legal to have multiple instances of this symbol in a single binary. The
linker will choose one of the duplicates to use.

- NOSPLIT = 4
(For TEXT items.) Don't insert the preamble to check if the stack must be split.
The frame for the routine, plus anything it calls, must fit in the spare space
at the top of the stack segment. Used to protect routines such as the stack
splitting code itself.

- RODATA = 8
(For DATA and GLOBL items.) Put this data in a read-only section.

- NOPTR = 16
(For DATA and GLOBL items.) This data contains no pointers and therefore does
not need to be scanned by the garbage collector.

- WRAPPER = 32
(For TEXT items.) This is a wrapper function and should not count as disabling
recover.

- NEEDCTXT = 64
(For TEXT items.) This function is a closure so it uses its incoming context
register.

* Runtime Coordination

For garbage collection to run correctly, the runtime must know the location of
pointers in all global data and in most stack frames. The Go compiler emits this
information when compiling Go source files, but assembly programs must define it
explicitly.

A data symbol marked with the NOPTR flag (see above) is treated as containing no
pointers to runtime-allocated data. A data symbol with the RODATA flag is
allocated in read-only memory and is therefore treated as implicitly marked
NOPTR. A data symbol with a total size smaller than a pointer is also treated as
implicitly marked NOPTR. It is not possible to define a symbol containing
pointers in an assembly source file; such a symbol must be defined in a Go
source file instead. Assembly source can still refer to the symbol by name even
without DATA and GLOBL directives. A good general rule of thumb is to define all
non-RODATA symbols in Go instead of in assembly.

Each function also needs annotations giving the location of live pointers in its
arguments, results, and local stack frame. For an assembly function with no
pointer results and either no local stack frame or no function calls, the only
requirement is to define a Go prototype for the function in a Go source file in
the same package. The name of the assembly function must not contain the package
name component (for example, function Syscall in package syscall should use the
name ·Syscall instead of the equivalent name syscall·Syscall in its TEXT
directive). For more complex situations, explicit annotation is needed. These
annotations use pseudo-instructions defined in the standard #include file
funcdata.h.

If a function has no arguments and no results, the pointer information can be
omitted. This is indicated by an argument size annotation of $n-0 on the TEXT
instruction. Otherwise, pointer information must be provided by a Go prototype
for the function in a Go source file, even for assembly functions not called
directly from Go. (The prototype will also let go vet check the argument
references.) At the start of the function, the arguments are assumed to be
initialized but the results are assumed uninitialized. If the results will hold
live pointers during a call instruction, the function should start by zeroing
the results and then executing the pseudo-instruction GO_RESULTS_INITIALIZED.
This instruction records that the results are now initialized and should be
scanned during stack movement and garbage collection. It is typically easier to
arrange that assembly functions do not return pointers or do not contain call
instructions; no assembly functions in the standard library use
GO_RESULTS_INITIALIZED.

If a function has no local stack frame, the pointer information can be omitted.
This is indicated by a local frame size annotation of $0-n on the TEXT
instruction. The pointer information can also be omitted if the function
contains no call instructions. Otherwise, the local stack frame must not contain
pointers, and the assembly must confirm this fact by executing the
pseudo-instruction NO_LOCAL_POINTERS. Because stack resizing is implemented by
moving the stack, the stack pointer may change during any function call: even
pointers to stack data must not be kept in local variables.

Assembly functions should always be given Go prototypes, both to provide pointer
information for the arguments and results and to let go vet check that the
offsets being used to access them are correct.
